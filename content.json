{"pages":[],"posts":[{"title":"HexoTest","text":"1 Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 2 NEW: DevDocs now comes with syntax highlighting. DevDocstwitter.com/devdocs/status/356095192085962752 3 1234567public class SinglyListNode { int val; SinglyListNode next; SinglyListNode(int x) { val = x; }} 1234for(int i=0;i&lt;length;i++) { printf(\"%3d\",a[i]); } 4 Arrays.sort()12Arrays.sort(a[]);int a=0; 5 _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 6 7 Hexo Tag Plugins 8 content","link":"/2019/03/20/Hexo/"},{"title":"查找Java版","text":"顺序查找 基本思想： 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第n个和第n-1个，将小数放前，大数放后。然后比较第n-1个数和第n-2个数，将小数放前，大数放后，如此继续，直至全部排序完成。 123456789101112 /** * 顺序查找 * @param 数组；查找的元素 * @return 下标 */static int SequenceSearch(int[] a,int num) { for (int i = 0; i &lt; a.length; i++) { if(a[i]==num) return i+1; } return -1;} 折半（二分）查找 基本思想： 搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。仅限有序数组 123456789101112131415161718192021/*** 二分查找(只能查找有序数组)* @param 数组；查找的元素* @return 下标*/ static int BinarySearch(int[] a,int num) { int low = 0; int high = a.length-1; int mid; while(low&lt;=high) { mid = (low + high) / 2; if(a[mid] &gt; num) { high=mid-1; }else if(a[mid] &lt; num) { low=mid+1; }else { return mid+1; } } return -1; }","link":"/2019/03/21/JavaSearch/"},{"title":"排序Java版","text":"冒泡排序 基本思想： 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第n个和第n-1个，将小数放前，大数放后。然后比较第n-1个数和第n-2个数，将小数放前，大数放后，如此继续，直至全部排序完成。 12345678910111213141516171819/** * 冒泡排序 * @param 数组 * @return 排好序的数组 */ static int[] BubbleSort(int[] a) { for (int i = a.length-1; i &gt;= 0; i--) { for (int j = i; j &gt; 0; j--) { if(a[j]&lt;a[j-1]) swap(a, j, j-1); } } return a; } static void swap(int[] a,int i,int j) { int t=a[i]; a[i]=a[j]; a[j]=t; } 插入排序 基本思想： 把n个待排序的元素看成一个有序表和一个无序表，开始时有序表中只有一个元素，无序表中有n-1个元素；排序过程即每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表，重复n-1次完成整个排序过程。 12345678910111213141516171819202122/** * 插入排序Eg： [9| 7, 4, 0, 5] [7, 9| 4, 0, 5] [4, 7, 9| 0, 5] [0, 4, 7, 9| 5] [0, 4, 5, 7, 9] */static int[] InsertSort (int a[]) { int t=0; for (int i = 1; i &lt; a.length; i++) { t=a[i]; for (int j = i-1 ; j &gt;= 0; j--) { if(t&lt;a[j]) swap(a,j,j+1); else continue; }// System.out.println(Arrays.toString(a)); } return a;} 时间复杂度 排序法 最差时间分析 平均时间复杂度 稳定度 空间复杂度 冒泡排序 O(n2) O(n2) 稳定 O(1) 快速排序 O(n2) O(n*log2n) 不稳定 O(log2n)~O(n) 选择排序 O(n2) O(n2) 不稳定 O(1) 二叉树排序 O(n2) O(n*log2n) 不一定 O(n) 插入排序 O(n2) O(n2) 稳定 O(1) 堆排序 O(n*log2n) O(n*log2n) 不稳定 O(1) 希尔排序 O O 不稳定 O(1) ext install paste-image-to-qiniu","link":"/2019/03/21/JavaSort/"},{"title":"Markdown","text":"标题这是 H1这是 H2这是 H3 段落 This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in,laoreet vitae, risus. 列表 This is a list This is a list This is a list This is a list This is a list This is a list This is a list This is a list 代码Use the printf() function. 123&lt;div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 1System.out.println(); 强调single asterisks single underscores double asterisks double underscores","link":"/2019/03/18/MarkDown/"},{"title":"递归","text":"递归问题：我们可以用「分而治之」的概念去帮助理解。步骤如下： 把问题分解成更容易解决的子问题集合（比如可以把计算斐波那契数列的第n项问题分解转换成计算第n-1项加上第n-2项这两个子问题） 假设我们有一个函数可以应用在所有的子问题上（比如计算斐波那契数列的fibo函数） 基于步骤2的函数，实现如何把子问题的解拼成最终问题的解，这就是递归部分（在计算斐波那契数列的例子里就是fibo(n-1) + fibo(n-2)部分） 递归部分确定了，然后再考虑子问题最终简化到到最底层时该返回什么值（不能再分的原子情况）。 E.g：问题描述 每年冬天，北大未名湖上都是滑冰的好地方。北大体育组准备了许多冰鞋，可是人太多了，每天下午收工后，常常一双冰鞋都不剩。 每天早上，租鞋窗口都会排起长龙，假设有还鞋的m个，有需要租鞋的n个。现在的问题是，这些人有多少种排法，可以避免出现体育组没有冰鞋可租的尴尬场面。（两个同样需求的人（比如都是租鞋或都是还鞋）交换位置是同一种排法）输入格式 两个整数，表示m和n输出格式 一个整数，表示队伍的排法的方案数。样例输入3 2样例输出5数据规模和约定m,n∈［0,18］ 1234567891011121314151617181920import java.util.*;public class Main{ public static void main(String[] args){ Scanner in = new Scanner(System.in); int m=in.nextInt();//send int n=in.nextInt();//get System.out.println(cal(m,n)); } static int cal(int m,int n) { if(n&gt;m) { return 0; } if(n==0) { return 1; } return cal(m-1,n)+cal(m,n-1); }} 类似问题 计算m个a n个b 的排列数 1234567891011121314151617181920public class Main{ /** * 计算m个a n个b 的排列数 */ public static void main(String[] args){ Scanner in = new Scanner(System.in); int m=in.nextInt();//a int n=in.nextInt();//b System.out.println(cal(m,n)); } static int cal(int a,int b) { if(a==0&amp;&amp;b==0) { return 0; } if(a==0||b==0) { return 1; } return cal(a-1,b)+cal(a,b-1); }} 计算斐波那契数 123456789101112131415161718192021import java.util.*;public class Main{ /** * 计算斐波那契数 */ public static void main(String[] args){ Scanner in = new Scanner(System.in); int n=in.nextInt();//a System.out.println(cal(n)); } static int cal(int n) { if(n==0) return 0; if(n==1) return 1; return cal(n-1)+cal(n-2);//第n个数为n-1,n-2的和 }}","link":"/2019/03/22/recursion/"},{"title":"My First Page","text":"Deploy to remote sites1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d More info: Deployment","link":"/2018/12/18/hello-world/"}],"tags":[{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"查找","slug":"查找","link":"/tags/查找/"},{"name":"Search","slug":"Search","link":"/tags/Search/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"递归","slug":"递归","link":"/tags/递归/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"}],"categories":[{"name":"Grammar","slug":"Grammar","link":"/categories/Grammar/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"}]}