{"pages":[],"posts":[{"title":"C语言 指针","text":"建立数组123456char a[6];a[0]='s';a[1]='w';a[2]='3';a[5]='q';char *t=a; a 为固定指针是数组a的首地址，不可直接进行运算。但可以通过以 [基地址+偏移量] 的思想来进行操作。 1234567printf(\"1--%d\\n\",a); //a 数组的首地址,即a[0]的地址 printf(\"2--%d\\n\",&amp;a); //a 数组的首地址printf(\"3--%d\\n\",&amp;a[5]); //a[5]的地址, printf(\"4--%s\\n\",&amp;a[1]); //a数组中从a[1]开始的字符串，{w3} printf(\"5--%c\\n\",a[1]); //a[1]的内容(char),{w}printf(\"6--%d\\n\",*a); //a[0]的内容(char),{115} t为浮动指针，初始化为指向数组a的首地址（注意区分a,t的不同），可直接进行运算来操作。 1234567printf(\"8--%d\\n\",t); //a 数组的首地址printf(\"9--%d\\n\",&amp;t); //t指针的地址printf(\"10--%d\\n\",&amp;t[5]); //a[5]的地址printf(\"11--%s\\n\",&amp;t[1]);//a数组中从a[0]开始的字符串，{w3} printf(\"12--%c\\n\",t[0]);//a[1]的内容(char),{w}printf(\"13--%c\\n\",*t); //a[0]的内容(char),{115} 对t进行操作 123456t++;printf(\"14--%d\\n\",t); //a[1] 的地址*t='c';printf(\"15--%c\\n\",*t); //a[1] 的值，{c} printf(\"16--%c\\n\",a[1]); //a[1] 的值，{c}","link":"/2019/04/20/C_Pointer/"},{"title":"DFS深度优先搜索","text":"递归解法(可能导致堆栈溢出)12345678910boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) { return true if cur is target; for (next : each neighbor of cur) { if (next is not in visited) { add next to visted; return true if DFS(next, target, visited) == true; } } return false;} 非递归解法1234567891011121314151617boolean DFS(int root,int target){ Set&lt;Node&gt; visited; Stack&lt;Node&gt; s; add root to s; while(s is not empty){ Node cur = the top element in s; return true if cur is target; for(Node next : the neighbors of cur){ if(next is not in visited){ add next to s; add next to visited; } } remove cur from s ; } return false;} 这里，只要深刻的理解了栈的概念就很容易理解。 我们来看一个简单的问题 二叉树的中序遍历输出TreeNode中节点的值 中序遍历：左-&gt;中-&gt;右 树的节点123456public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }} 递归解法： 12345678910111213141516class Solution { List&lt;Integer&gt; list = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { f1(root); return list; } void f1(TreeNode root){ if(root == null) return ; //当有左节点的时候就一直递归到没有左节点为止。 inorderTraversal(root.left); //第一次运行到这里的时候，这一定是最左边的节点。 list.add(root.val); //第一次运行到这里的时候，左边节点和父节点已经遍历了。 inorderTraversal(root.right); }} 迭代解法： 123456789101112131415161718192021222324252627class Solution { //用于输出结果的数组。 List&lt;Integer&gt; list = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { //如果当前节点不为空将其放入栈中。 Stack&lt;TreeNode&gt; st = new Stack(); //curr指针指向root TreeNode curr = root; //查找所有子节点 while(curr!=null||!st.isEmpty()){ //不为空就继续找下一个左节点。并压入栈中。 if(curr!=null){ st.push(curr); curr = curr.left; }else{ /* 如果当前节点为空，有两种情况。 1.到了最左边。 2.到了最右边。 */ curr = st.pop(); list.add(curr.val); curr = curr.right; } } return list; }","link":"/2019/03/23/Alg_DFS/"},{"title":"EverMonkey印象笔记插件","text":"开始使用 打开命令面板(F1 或者 ctrl+shift+p), 输入以下命令即可操作印象笔记。 新建笔记 – ever new 新建一个空白笔记, 文档顶部是笔记元数据，包括笔记的标题，标签，所属笔记本等(不支持分级)。 当输入笔记本和标签时，如果是已经存在的，则会有代码补全提示，否则将会在印象笔记中新建。标签需要用半角逗号分隔。 打开笔记 – ever open 以树形结构打开印象笔记。选中笔记后，默认会将笔记的内容转换为 markdown 格式，如果有不支持的媒体格式，那么转换后可能会影响笔记的内容。如果在多端进行编辑也会出现 html 标签的情况。 搜索笔记 – ever search 根据输入的搜索条件返回印象笔记。返回的形式是 notebook&gt;&gt;note, 搜索使用的是印象笔记官方的搜索语言，比如 tag:java 等。更多使用方法可以查看官方文档 Evernote Search Grammar 发布笔记 – ever publish 当编辑或者更新笔记后，可以使用 ever publish 命令将笔记发布到印象笔记服务器上，实现笔记的同步。monkey 会根据缓存信息判断是需要新建还是更新笔记, 更新成功后会弹出消息。 打开最近编辑的笔记 – ever recent 打开最近编辑过的笔记。选中笔记后，默认会将笔记的内容转换为 markdown 格式，如果有不支持的媒体格式，那么转换后可能会影响笔记的内容。如果在多端进行编辑也会出现 html 标签的情况。 在浏览器中打开编辑的笔记 – ever browse 在印象笔记网页端打开当前编辑的笔记，如果还未发布，则无法打开。如果在网页端中编辑文档内容，再次在vscode中打开笔记时，渲染markdown会导致一些原生html被渲染。 在客户端中浏览编辑的笔记 – ever everclient 在印象笔记客户端中打开编辑的笔记，如果还未发布，则无法打开。如果在客户端中编辑文档内容，再次在vscode中打开笔记时，渲染markdown会导致一些原生html被渲染。 上传附件到当前编辑的笔记 – ever attach 如果已经配置了 uploadFolder, 可以将附件放到对应的文件夹下，输入文件名即可实现上传。否则，需要输入文件的绝对路径。上传后的附件是缓存在本地的，需要使用 ever publish 命令将附件上传。 取消上传附件到当前编辑的笔记 – ever unattach 如果附件上传后还没有 publish, 此时可以使用 ever unattach 命令进行取消。 注: monkey 中不提供任何删除服务器端笔记的命令！ 浏览当前编辑笔记的附件 – ever resources 浏览当前编辑的笔记。其中会以 (server), (local) 的形式区分本地附件和服务器附件。如果是服务器端的附件，选中后会临时下载到 attachmentsFolder 中, 并使用默认应用打开附件。 如果是本地附件，则会直接使用默认应用打开。 同步笔记账户 – ever sync 同步笔记账户，这个命令会在第一次使用 monkey 的时候调用，并将结果缓存到内存中。如果没有缓存报错(通常是由于网络原因导致请求失败，本地缓存失效), 或者在多端使用印象笔记，不建议使用此命令。可能会由于印象笔记限流导致，账户暂时无法调用 API。 打开印象笔记开发者网页 – ever token 获取 token 和 noteStoreUrl。","link":"/2019/03/23/Evermonkey/"},{"title":"Git Start!","text":"常用命令 123pwd 用于显示当前目录mkdir 建立目录touch 建立文件 Git Git 基本操作 git init 选择一个空目录初始化 创建指定目录learngit并加入readme 1234$ mkdir learngit$ cd learngit/$ touch readme.txt$ git add readme.txt //可反复多次使用，添加多个文件到暂存区 git status 查看添加到工作区与暂存区的内容是否一致 当在本地发生了修改可以通过git diff查看修改的变化$ git diff readme.txt 提交所有暂存区的内容到仓库+提交说明（方便管理）$ git commit -m &quot;wrote a readme file&quot; 可以使用git log查看提交的日志，通过commit后的版本号回退版本commit 461a4c83a94bc47621c873d30b9165db9e48c78d 查看日志图表 $ git log --graph 查看简洁版日志图表 $ git log --graph --pretty=oneline --abbrev-commit 回退 回退暂存区的特定文件（暂存区-&gt;工作区）$ git reset -- filename 回退到前一个版本$ git reset --hard HEAD^ 回退到特定版本（使用版本号不发生重复的前n位&gt;3）$ git reset --hard 461a 查询恢复版本的记录$ git reflog 撤销工作区的修改（暂存区-&gt;工作区）$ git checkout -- readme.txt 撤销暂存区的修改（仓库-&gt;暂存区）$ git reset HEAD readme.txt 删除文件使用git rm将修改保存到暂存区$ git rm readme.txt 连接本地仓库到GitHub 创建SSH Key$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 将id_rsa.pub 添加到GitHub 登陆GitHub-&gt;“Account settings”-&gt;“SSH Keys”添加“SSH Key”，任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 GitHub上建立新仓库learngit 本地与在线仓库关联$ git remote add origin git@github.com:arnoldteams/learngit.git 远程库的名字是origin关联仓库为arnoldteams/learngit 将本地推送到GitHub仓库$ git push -u origin master推送失败可以先进行合并$ git pull --rebase origin master 连接完成后若本地仓库发生修改进行推送$ git push origin master GitHub 仓库克隆到本地$ git clone git@github.com:arnoldteams/learngit.git或者$ git clone https://github.com/Arnoldteams/learngit 分支 初始只有master分支 添加dev分支 创建及切换分支 方法112$ git branch dev$ git checkout dev 方法21$ git checkout -b dev 查看所有分支git branch 向dev提交 合并分支 合并dev到当前分支$ git merge dev 保留新分支进行合并$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 删除分支$ git branch -d dev","link":"/2019/04/02/Git/"},{"title":"Stay Hungry!Stay Foolish!","text":"读书的目的 孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为：我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。 —龙应台 有意识的思考 不要让笔尖上的勤奋掩盖思维上的懒惰。 拒绝思维懒惰，习惯于深度思考，永远不要用战术上的勤奋掩盖战略上的懒惰。 微笑面对苦难 那些承载着苦难的时光，那些从根本上挑战每一份坚持的日子，将决定你是怎样的人。—谢丽尔·桑德 无论生活再艰难，也要用力活着—《荒野猎人》 风吹不倒有根的树。只要一息尚存，就战斗到底。 尊严的背后是实力 尊严只有在双方对等地位时才存在，弱者的尊严在强者面前一文不值，强者可以施舍给你“尊严”，但他可以以毫不犹豫的践踏，因为他是强者，与此拼命维护那施舍来的尊严，不如拼命提升自己的实力","link":"/2019/03/22/Good_Words001/"},{"title":"My First Page","text":"Deploy to remote sites1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d More info: Deployment","link":"/2018/12/18/Hello-world/"},{"title":"HexoTest","text":"1 Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 2 NEW: DevDocs now comes with syntax highlighting. DevDocstwitter.com/devdocs/status/356095192085962752 3 1234567public class SinglyListNode { int val; SinglyListNode next; SinglyListNode(int x) { val = x; }} 1234for(int i=0;i&lt;length;i++) { printf(\"%3d\",a[i]); } 4 Arrays.sort()12Arrays.sort(a[]);int a=0; 5 _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 6 7 Hexo Tag Plugins 8 content","link":"/2019/03/20/Hexo/"},{"title":"字符串 数组","text":"字符串 转义字符 1'I\\'m \\\"OK\\\"!';//表示的字符串内容是：I'm \"OK\"! 按位置查找 1234var s = 'Hello, world!';s[0]; // 'H's[6]; // ' 's[7]; // 'w' toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf()搜索指定字符串出现的位置 字符串截取 substring()123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' 数组 length 修改 1234var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined] 索引赋值超限 123var arr = [1, 2, 3];arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 按位置查找 indexOf()12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 截取 slice()123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] push和pop(尾操作) 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift和shift（头操作） 123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] 排序 sort() 翻转 reverse() 元素的添加和删除 splice()12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] 连接 concat()1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] join()12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3'","link":"/2019/05/03/JavaScript_Str&Arr/"},{"title":"Arrays常用方法","text":"1.Arrays.fill(Object[] array, Object obj) 填充 12345678910//用指定元素填充整个数组（会替换掉数组中原来的元素）Integer[] data = {1, 2, 3, 4};Arrays.fill(data, 9);System.out.println(Arrays.toString(data)); // [9, 9, 9, 9]Arrays.fill(Object[] array, int fromIndex, int toIndex, Object obj)Integer[] data = {1, 2, 3, 4};Arrays.fill(data, 0, 2, 9);System.out.println(Arrays.toString(data)); // [9, 9, 3, 4] 2.Arrays.sort(Object[] array) 排序 1234567891011//对数组元素进行排序（串行排序）String[] data = {\"1\", \"4\", \"3\", \"2\"};System.out.println(Arrays.toString(data)); // [1, 4, 3, 2]Arrays.sort(data);System.out.println(Arrays.toString(data)); // [1, 2, 3, 4]Arrays.sort(data, 0, 3);// 对下标[0, 3)的元素进行排序，即对1，4，3进行排序，2保持不变System.out.println(Arrays.toString(data)); // [1, 3, 4, 2]Arrays.parallelSort(T[] array)//对数组元素进行排序（并行排序），当数据规模较大时，会有更好的性能 3.Arrays.binarySearch(Object[] array, Object key) 查找（二分法） 注意: 在调用该方法之前，必须先调用sort()方法进行排序，如果数组没有排序，那么结果是不确定的，此外如果数组中包含多个指定元素，则无法保证将找到哪个元素1234567Integer[] data = {1, 3, 5, 7};Arrays.sort(data);System.out.println(Arrays.binarySearch(data, 1)); // 0System.out.println(Arrays.binarySearch(data, 0)); // -1 ；-(0 + 1) = -1System.out.println(Arrays.binarySearch(data, 8)); // -5 ；-(4 + 1) = -5System.out.println(Arrays.binarySearch(data, 2)); // -2 ；-(1 + 1) = -2System.out.println(Arrays.binarySearch(data, 0, 2, 3)); // 1 4.Arrays.copyOf(T[] original, int newLength) 拷贝数组 12345678Integer[] data1 = {1, 2, 3, 4};Integer[] data2 = Arrays.copyOf(data1, 2);System.out.println(Arrays.toString(data2)); // [1, 2]Integer[] data2 = Arrays.copyOf(data1, 5);System.out.println(Arrays.toString(data2)); // [1, 2, 3, 4, null]Arrays.copyOfRange(T[] original, int from, int to)//指定起始位置和结束位置，如果超过原数组长度，会用null进行填充 5.Arrays.equals(Object[] array1, Object[] array2) 判断两个数组是否相等 12345678910//实际上比较的是两个数组的哈希值，即 Arrays.hashCode(data1) == Arrays.hashCode(data2)Integer[] data1 = {1, 2, 3};Integer[] data2 = {1, 2, 3};System.out.println(Arrays.equals(data1, data2)); // trueArrays.deepEquals(Object[] array1, Object[] array2)//判断两个多维数组是否相等，实际上比较的是两个数组的哈希值，即 :Arrays.hashCode(data1) == Arrays.hashCode(data2) 6.Arrays.hashCode(Object[] array) 哈希值 123456//返回数组的哈希值Integer[] data = {1, 2, 3};System.out.println(Arrays.hashCode(data)); // 30817 Arrays.deepHashCode(Object[] array)//返回多维数组的哈希值 7.Arrays.toString(Object[] array) 输出 123456789//返回数组元素的字符串形式Integer[] data = {1, 2, 3};System.out.println(Arrays.toString(data)); // [1, 2, 3]Arrays.deepToString(Object[] array)//返回多维数组元素的字符串形式Integer[][] data = {{1, 2, 3}, {1, 2, 3}};System.out.println(Arrays.deepToString(data)); // [[1, 2, 3], [1, 2, 3]] 8.Arrays.setAll(T[] array, IntFunction) 123Integer[] data = {1, 2, 3, 4}; // i为索引值Arrays.setAll(data, i -&gt; data[i] * 2);System.out.println(Arrays.toString(data)); // [2, 4, 6, 8] 9.Arrays.stream(T[] array) 1234//返回数组的流Stream，然后我们就可以使用Stream相关的许多方法了Integer[] data = {1, 2, 3, 4};List&lt;Integer&gt; list = Arrays.stream(data).collect(toList());System.out.println(list); // [1, 2, 3, 4]","link":"/2019/03/23/Java_Arr/"},{"title":"LinkedList常用方法","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public E getFirst()//获取头元素public E getLast()public E removeFirst()//删除public E removeLast()public E remove(int index)//删除指定位置的元素public boolean remove(Object o)//删除指定值的元素public boolean add(E e) //增加public void addFirst(E e)public void addLast(E e)public void add(int index, E element)//在指定位置插入指定元素public boolean contains(Object o)//测试列表是否包含某元素，包含返回truepublic int size()//返回链表大小public boolean remove(Object o)//删除列表中第一个遇到的指定元素，成功返回truepublic boolean addAll(Collection&lt;? extends E&gt; c)//把指定集合中的所有元素追加到列表末尾，成功返回truepublic E get(int index)//返回元素在列表中位置public E set(int index, E element)//用指定元素E替换原指定位置的元素，返回被替换的元素public int indexOf(Object o)//返回第一个遇到的指定元素的位置，没有返回-1public int lastIndexOf(Object o)//返回最后一个遇到的指定元素的位置Integer[] str=link.toArray(new Integer[link.size()]);//LinkedList-&gt;&lt;T&gt;[] ArrayList&lt;Integer&gt; myList = new ArrayList&lt;Integer&gt;(link);//LinkedList-&gt;ArrayList","link":"/2019/03/23/Java_LinkedList/"},{"title":"HashMap&TreeMap","text":"HashMap： 数组方式存储key/value，线程非安全，允许null作为key和value，key不可以重复，value允许重复，不保证元素迭代顺序是按照插入时的顺序，要求key必须重写equals和hashcode方法。 TreeMap： 基于红黑二叉树实现，线程非安全，不允许null，key不可以重复，value允许重复，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，默认升序，两个相比较的key不得抛出classCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出。 HashMap：1234567891011121314151617181. 存入键值对V put ( K key, V value )//向map中添加键值对后，返回这个key对应以前的value,如果以前没有则返回nullV putIfAbsent (K key, V value)// 在输入键值对前，会先判断map中是否有相同key，如果有就不覆盖，返回原有的value，如果没有就返回null，并直接存入。E.g:hashMap.putIfAbsent(\"A\",16); hashMap.putIfAbsent(\"A\",17);hashMap.putIfAbsent(\"B\", 100); hashMap.putIfAbsent(\"B\", 150);hashMap.put(\"C\", 222); hashMap.put(\"C\", 23);Out：A=16, B=100, C=23void putAll ( Map&lt;? extends K,? extends V&gt; m)//把一个其他map复制过来 123456789101112131415162. 通过键取值 V get(K key)//如果map有key则获取value，没有则返回null，也有可能有key但对应的value就是null，所以不能用get判断是否存在某个key。V getOrDefault(K key, V defaultValue)//如果map有key则获取value，没有则返回自定义的defaultValue3. 键或值是否存在boolean containsValue(Object value)boolean containsKey(Object key)4. 替换键值对V replace(K key, V Value)//如果map中存在key则将其对应的value替换为参数里的value，并返回以前的value，如果不存在key则返回null。boolean replace(K key, V oldValue, V newValue)//匹配map中对应的键值对，如果完全符合就替换，不符合就返回false。void replaceAll(BiFunction function)//对所有键值对进行替换 123456789101112131415161718192021225. 删除键值对V remove(K key)//通过key删除键值对，返回key对应的value，如果不存在key返回nullboolean remove(K key, V Value)//只有完全匹配参数中的键值对才删除。6. 元素数据处理（函数式编程）V computeIfPresent(K key, BiFunctionsuper K, ? super V, ? extends V&gt; remappingFunction)V computeIfAbsent (K key, Functionsuper K, ? extends V&gt; mappingFunction)V compute (K key, BiFunctionsuper K, ? super V, ? extends V&gt; remappingFunction)V merge(K key, V value,BiFunction remappingFunction)//上面这些功能简单来说就是 用自定义方法更新key对应的value。void forEach ( BiConsumer action)//这个更好理解了，就是对map所有键值对进行操作7. 获取 键/值 的集合Collection&lt;V&gt; values()//获取map中的所有value，并存入CollectionSet&lt;K&gt; keySet()//获取map中的所有key，存入setSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()//获取map中所有键值对，存入set，注意这里的返回类型是个map特有的接口Map.Entry的set集合，一个Map.Entry接口对应map中的一个键值对，Map.Entry是个静态接口，可以通过foreach或迭代器，调用每个接口的set/get方法，其实Map.Entry可以看作键值对的实体类 TreeMap：注意：之所以会有这些方法，是因为treemap是有序的。查找限定范围内的一个key或entry1234567891011121314151617181920212223Map.Entry&lt;K,V&gt; ceilingEntry(K key)K ceilingKey(K key)//查找大于等于参数key的map里包含的最小key或entry，没有就返回nullMap.Entry&lt;K,V&gt; floorEntry(K key)K floorKey(K key)//查找小于等于参数key的map里包含的最大key或entry，没有就返回nullMap.Entry&lt;K,V&gt; lowerEntry(K key)K lowerKey(K key)//查找小于参数key的map里包含的最大key或entry，没有就返回nullMap.Entry&lt;K,V&gt; higherEntry(K key)K higherKey(K key)//查找大于参数key的map里包含的最小key或entry，没有就返回nullMap.Entry&lt;K,V&gt; firstEntry(K key)K firstKey(K key)//查找map中最小的键（第一个）Map.Entry&lt;K,V&gt; lastEntry(K key)K lastKey(K key) //查找map中最大的键（最后一个）3. 删除最大或最小键值对SortedMap&lt;K,V&gt; headMap(K toKey)//返回Key小于toKey的所有元素Map.Entry&lt;K,V&gt; pollFirstEntry() Map.Entry&lt;K,V&gt; pollLastEntry() //返回被删除的键值对 Link: TreeMap","link":"/2019/03/23/Java_HashMap&TreeMap/"},{"title":"ArrayList常用方法","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 创建一个空的数组链表对象list，list用来存放String类型的数据 // 增加元素到list对象中 list.add(\"Item1\"); list.add(\"Item2\"); list.add(2, \"Item3\"); // 此条语句将会把“Item3”字符串增加到list的第3个位置。 list.add(\"Item4\");// 检查元素的位置 int pos = list.indexOf(\"Item2\"); System.out.println(\"The index of Item2 is: \" + pos); // 检查数组链表是否为空 boolean check = list.isEmpty(); System.out.println(\"Checking if the arraylist is empty: \" + check); // 获取链表的大小 int size = list.size(); System.out.println(\"The size of the list is: \" + size); // 检查数组链表中是否包含某元素 boolean element = list.contains(\"Item5\"); System.out .println(\"Checking if the arraylist contains the object Item5: \" + element); // 获取指定位置上的元素 String item = list.get(0); System.out.println(\"The item is the index 0 is: \" + item); // 使用迭代器遍历list for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext();) { System.out.println(\"Item is: \" + it.next()); } // 替换元素 list.set(1, \"NewItem\"); System.out.println(\"The arraylist after the replacement is: \" + list); // 移除第0个位置上的元素 list.remove(0); // 移除第一次找到的 \"Item3\"元素 list.remove(\"Item3\"); // 转换 ArrayList 为 Array String[] simpleArray = list.toArray(new String[list.size()]);","link":"/2019/03/23/Java_ArrayList/"},{"title":"Math数学常用方法","text":"Math1234567891011Math.sqrt()//计算平方根Math.cbrt()//计算立方根Math.pow(a, b)//计算a的b次方Math.max( , );//计算最大值Math.min( , );//计算最小值Math.abs()//abs求绝对值Math.ceil()//向上取整Math.floor()//向下取整Math.random()//随机数Math.round()//四舍五入Math.rint//四舍六入五凑偶 BigInteger (BigDecimal 用法相同)12345678910public BigInteger add(BigInteger val)public BigInteger subtract(BigInteger val)public BigInteger multiply(BigInteger val)public BigInteger divide(BigInteger val)\"int compareTo(Biglnteger other)//如果这个大整数与另一个大整数相等，返回0; 如果这个大整数小于另一个大整数, 返回负数；否则，返回正数","link":"/2019/03/23/Java_Math/"},{"title":"递归","text":"递归问题：我们可以用「分而治之」的概念去帮助理解。步骤如下： 把问题分解成更容易解决的子问题集合（比如可以把计算斐波那契数列的第n项问题分解转换成计算第n-1项加上第n-2项这两个子问题） 假设我们有一个函数可以应用在所有的子问题上（比如计算斐波那契数列的fibo函数） 基于步骤2的函数，实现如何把子问题的解拼成最终问题的解，这就是递归部分（在计算斐波那契数列的例子里就是fibo(n-1) + fibo(n-2)部分） 递归部分确定了，然后再考虑子问题最终简化到到最底层时该返回什么值（不能再分的原子情况）。 E.g：问题描述 每年冬天，北大未名湖上都是滑冰的好地方。北大体育组准备了许多冰鞋，可是人太多了，每天下午收工后，常常一双冰鞋都不剩。 每天早上，租鞋窗口都会排起长龙，假设有还鞋的m个，有需要租鞋的n个。现在的问题是，这些人有多少种排法，可以避免出现体育组没有冰鞋可租的尴尬场面。（两个同样需求的人（比如都是租鞋或都是还鞋）交换位置是同一种排法）输入格式 两个整数，表示m和n输出格式 一个整数，表示队伍的排法的方案数。样例输入3 2样例输出5数据规模和约定m,n∈［0,18］ 1234567891011121314151617181920import java.util.*;public class Main{ public static void main(String[] args){ Scanner in = new Scanner(System.in); int m=in.nextInt();//send int n=in.nextInt();//get System.out.println(cal(m,n)); } static int cal(int m,int n) { if(n&gt;m) { return 0; } if(n==0) { return 1; } return cal(m-1,n)+cal(m,n-1); }} 类似问题 计算m个a n个b 的排列数 1234567891011121314151617181920public class Main{ /** * 计算m个a n个b 的排列数 */ public static void main(String[] args){ Scanner in = new Scanner(System.in); int m=in.nextInt();//a int n=in.nextInt();//b System.out.println(cal(m,n)); } static int cal(int a,int b) { if(a==0&amp;&amp;b==0) { return 0; } if(a==0||b==0) { return 1; } return cal(a-1,b)+cal(a,b-1); }} 计算斐波那契数 123456789101112131415161718192021import java.util.*;public class Main{ /** * 计算斐波那契数 */ public static void main(String[] args){ Scanner in = new Scanner(System.in); int n=in.nextInt();//a System.out.println(cal(n)); } static int cal(int n) { if(n==0) return 0; if(n==1) return 1; return cal(n-1)+cal(n-2);//第n个数为n-1,n-2的和 }}","link":"/2019/03/22/Java_Recursion/"},{"title":"查找Java版（线性结构）","text":"顺序查找 基本思想： 依次查找 SequenceSearch123456789101112 /** * 顺序查找 * @param 数组；查找的元素 * @return 下标 */static int SequenceSearch(int[] a,int num) { for (int i = 0; i &lt; a.length; i++) { if(a[i]==num) return i+1; } return -1;} 折半（二分）查找 基本思想： 搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。仅限有序数组 BinarySearch123456789101112131415161718192021 /** * 二分查找(只能查找有序数组) * @param 数组；查找的元素 * @return 下标 */static int BinarySearch(int[] a, int num) { int low = 0; int high = a.length - 1; int mid; while (low &lt;= high) { mid = (low + high) / 2; if (a[mid] &gt; num) { high = mid - 1; } else if (a[mid] &lt; num) { low = mid + 1; } else { return mid + 1; } } return -1;} 分块查找 基本思想： 将n个数据元素按块有序划分为m块（m&lt;=n）。每一块中的数据元素不必有序，但块与块之间必须“按块有序”，即第1快中的任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都小于第3块中的任一元素，……；块间用顺序 OR 二分查找，块内用顺序查找 TestData12int[][] tab= {{24,1},{54,7},{78,10},{88,13}};//索引表int[] a= {24,21,6,11,8,22,32,31,54,72,61,78,88,83};//查找数组 DivideSearch123456789101112131415161718192021222324/** * @param 查找数组；索引表；查找元素 * @return 下标 * 采用顺序+顺序（也可以使用二分+顺序实现） */static int DivideSearch(int[] a, int[][] tab, int num) { int start = -1; for (int i = 0; i &lt; tab.length; i++) { if (tab[i][0] == num) return tab[i][1]; if (tab[i][0] &gt; num) { start = tab[i][1] - 1; continue; } } if (start == -1) return -1; for (int i = start; i &gt;= 0; i--) { if (a[i] == num) return i + 1; } return -1;}","link":"/2019/03/21/Java_Search1/"},{"title":"SequenceList_Java 顺序表","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.Arrays;public class SequenceList&lt;T&gt; { static int MaxSize = 10; private T[] data; int length; public SequenceList() { } public boolean InitList(T[] list) { // 初始化 data = Arrays.copyOf(list, MaxSize); length = list.length; return true; } public boolean ListInsert(int i, T a) { // 插入 if (i &lt; 1 || i &gt; length + 1 || length &gt;= MaxSize) return false; for (int j = length; j &gt;= i; j--) { data[j] = data[j - 1]; } data[i - 1] = a; length++; return true; } public Object ListDelete(int i) { // 删除 if (i &lt; 1 &amp;&amp; i &gt; length + 1) return -1; T temp = data[i - 1]; for (int j = i; j &lt; length; j++) { data[j - 1] = data[j]; } length--; data[length] = null; return temp; } public int LocateElem(T a) { // 获取元素位置 for (int i = 0; i &lt; length; i++) { if (data[i] == a) return i + 1; } return -1; } public Object GetElem(int i) { // 获取元素 if (i &lt; 1 &amp;&amp; i &gt; length + 1) return -1; return data[i - 1]; } public int Length() { // 长度 return this.length; } public void print() { // 打印 System.out.println(Arrays.toString(data)); } public boolean Empty() { // 判断是否为空 if (data.length == 0) return true; return false; }//Test public static void main(String[] args) { Integer[] a = { 1, 2, 3, 4, 5 };// 使用int初始化会发生异常 SequenceList&lt;Integer&gt; list = new SequenceList&lt;Integer&gt;(); System.out.println(\"Init:\" + list.InitList(a)); System.out.println(\"Insert:\" + list.ListInsert(1, 66)); System.out.println(\"Delete:\" + list.ListDelete(4)); System.out.println(\"GetNum:\" + list.GetElem(4)); System.out.println(\"LocElem:\" + list.LocateElem(66)); System.out.println(\"Length:\" + list.length); System.out.println(\"Empty:\" + list.Empty()); list.print(); }}","link":"/2019/03/28/Java_SequenceList/"},{"title":"排序Java版(插入排序)","text":"直接插入排序 基本思想： 把n个待排序的元素看成一个有序表和一个无序表，开始时有序表中只有一个元素，无序表中有n-1个元素；排序过程即每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表，重复n-1次完成整个排序过程。 InsertSort123456789101112131415161718192021/** * 插入排序Eg： [9| 7, 4, 0, 5] [7, 9| 4, 0, 5] [4, 7, 9| 0, 5] [0, 4, 7, 9| 5] [0, 4, 5, 7, 9] */static int[] InsertSort (int a[]) { int t=0; for (int i = 1; i &lt; a.length; i++) { t=a[i]; for (int j = i-1 ; j &gt;= 0; j--) { if(t&lt;a[j]) swap(a,j,j+1); else continue; } } return a;} 时间复杂度 排序法 最差时间分析 平均时间复杂度 稳定度 空间复杂度 冒泡排序 O(n^2) O(n^2) 稳定 O(1) 快速排序 O(n^2) O(n*log2n) 不稳定 O(log2n)~O(n) 选择排序 O(n^2) O(n^2) 不稳定 O(1) 二叉树排序 O(n^2) O(n*log2n) 不一定 O(n) 插入排序 O(n^2) O(n^2) 稳定 O(1) 堆排序 O(n*log2n) O(n*log2n) 不稳定 O(1) 希尔排序 O O 不稳定 O(1)","link":"/2019/03/21/Java_Sort1/"},{"title":"排序Java版(交换排序)","text":"冒泡排序 基本思想： 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第n个和第n-1个，将小数放前，大数放后。然后比较第n-1个数和第n-2个数，将小数放前，大数放后，如此继续，直至全部排序完成。 BubbleSort123456789101112131415161718192021222324252627282930 /** * 冒泡排序 * @param 数组 * @return 排好序的数组 *///v1.0 由尾到头排序static int[] BubbleSort(int[] a) { for (int i = a.length - 1; i &gt;= 0; i--) { for (int j = i; j &gt; 0; j--) { if (a[j] &lt; a[j - 1]) swap(a, j, j - 1); } } return a;}//v2.0 由头到尾排序static int[] BubbleSort(int[] a) { for (int i = 0; i &lt;=a.length - 1; i++) { for (int j = i+1; j &lt;=a.length - 1; j++) { if (a[i] &gt; a[j]) swap(a, i, j); } } return a;}static void swap(int[] a, int i, int j) { int t = a[i]; a[i] = a[j]; a[j] = t;} 快速排序 基本思想： 第一趟选取一个哨兵，以哨兵为分界进行划分，将数组划分为 [low] 哨兵 [high] 使得 [low] 的所有元素均小于哨兵元素，[high] 的所有元素均大于哨兵元素（也就是说哨兵这个元素已经排到正确位置了），之后以这个哨兵为界分别对 [low] [high] 进行划分，递归进行直到完成排序 QuickSort12345678910111213141516171819202122232425262728293031323334353637 /** * 快速排序 * @param 数组，数组下限，数组上限 * @return 排好序的数组 */static int[] QuickSort(int[] a, int low, int high) { if (low &lt; high) { int pos = Partition(a, low, high); QuickSort(a, low, pos - 1); QuickSort(a, pos + 1, high); } return a;} /** * 划分 * @param 数组，数组下限，数组上限 * @return 哨兵的位置 */static int Partition(int[] a, int low, int high) { int sentry = a[low];// 哨兵 while (low &lt; high) { // 实现[low] 哨兵 [high] 的排序；当low=high时候结束循环 while (low &lt; high &amp;&amp; a[high] &gt;= sentry) { // 从high-&gt;low遍历；发现第一个a[high]&lt;哨兵 结束循环 high--; } a[low] = a[high]; // 将这个小于哨兵的元素移至哨兵左边[low] while (low &lt; high &amp;&amp; a[low] &lt;= sentry) { // 从low-&gt;high遍历；发现第一个a[high]&gt;哨兵 结束循环 low++; } a[high] = a[low]; // 将这个大于于哨兵的元素移至哨兵右边[high] } a[low] = sentry;// 哨兵放到正确的位置 return low;// 返回哨兵的位置，这时 哨兵的左边&lt;哨兵；哨兵的右边&gt;哨兵}","link":"/2019/04/01/Java_Sort2/"},{"title":"String常用方法","text":"12345678910111213141516171819202122232425261 length（）字符串的长度; isEmpty()判空2 charAt（）截取一个字符 String a = \"Hello Word\"; System.out.println(a.charAt(1));//输出的结果是字符串a的下标为1的字符e。3 getchars（）截取多个字符并由其他字符串接收 String a = \"Hello Word\"; char[] b = new char[10]; a.getChars(0, 5, b, 0); System.out.println(b);//输出的结果为Hello4 getBytes()将字符串变成一个byte数组 String a = \"Hello Word\"; byte b[] = a.getBytes(); System.out.println(new String(b));//输出的结果为Hello Word的byte数组。5 toCharArray()将字符串变成一个字符数组 String a = \"Hello Word\"; char[]b = a.toCharArray(); System.out.println(b);//输出的结果为Hello Word字符数组。 12345678910111213141516171819202122232425262728296 equals()和equalsIgnoreCase()比较两个字符串是否相等，前者区分大小写，后者不区分 String a = \"Hello Word\"; String b = \"hello word\"; System.out.println(a.equals(b));//false System.out.println(a.equalsIgnoreCase(b));//true7 startsWith()和endsWith()判断字符串是不是以特定的字符开头或结束 String a = \"Hello Word\"; System.out.println(a.startsWith(\"ee\"));//false System.out.println(a.endsWith(\"rd\"));//true8 toUpperCase()和toLowerCase()将字符串转换为大写或小写 String a = \"Hello Word\"; System.out.println(a.toUpperCase());//HELLO WORD System.out.println(a.toLowerCase());//hello word9 concat() 连接两个字符串 String a = \"Hello Word\"; String b = \"你好\"; System.out.println(b.concat(a));//你好Hello Word10 trim()去掉起始和结束的空格 String a = \" Hello Word \"; System.out.println(a.trim());//Hello Word 123456789101112131415161718192021222324252627282930313233343511 substring（）截取字符串 String a = \"Hello Word\"; System.out.println(a.substring(0, 5));//Hello System.out.println(a.substring(6));//World12 indexOf()和lastIndexOf()前者是查找字符或字符串第一次出现的地方，后者是查找字符或字符串最后一次出现的地方 String a = \"Hello Word\"; System.out.println(a.indexOf(\"o\"));//4 System.out.println(a.lastIndexOf(\"o\"));//713 compareTo()和compareToIgnoreCase(）按字典顺序比较两个字符串的大小，前者区分大小写，后者不区分 String a = \"Hello Word\"; String b = \"hello word\"; System.out.println(a.compareTo(b));//-32 System.out.println(a.compareToIgnoreCase(b));//014 replace() 替换 String s=\"abc\"; System.out.println(s.replace('a', 'w'));//wbc System.out.println(s.replaceFirst(\"bc\", \"cde\"));//acde15 contains() 字符串匹配 String s=\"ab,cd,ef\"; System.out.println(s.contains(\"ef\"));//true System.out.println(s.contains(\"ecf\"));//false16 split 拆分字符串 String s=\"sa sf gaf asd\"; String[] a=s.split(\" \");//[sa, sf, gaf,asd]","link":"/2019/03/23/Java_Str/"},{"title":"类型转换&进制转换(Java)","text":"类型转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//int-&gt;String1：String s=i+\"\";2：String s=String.valueOf(i);//int-&gt;char1:char c = (char)('0' + i);2:char c = (char)(48+ i);3:char c = String.valueOf(i).charAt(0);//String-&gt;int1：i=Integer.parseInt(s);2：i=Integer.valueOf(s).intValue();//Integer.valueOf(s) //转换数字字符串以外类型会抛出异常//String-&gt;byte[]1:byte[] b=s.getBytes();//String -&gt; char1. String.charAt(index)//（返回值为char）可以得到String中某一指定位置的char。2. String.toCharArray()//（返回值为char[]）可以得到将包含整个String的char数组。这样我们就能够使用从0开始的位置索引来访问string中的任意位置的元素。//byte[]-&gt;String1:String s=new String(b)//ASCII-&gt;char1:char c = (char) 68;//D //char-&gt;ASCIISystem.out.println((int)'c');//99//char-&gt;int1:int i=Integer.parseInt(String.valueOf(c)) ;2:int i=c-'0';//char -&gt;String1. String s = String.valueOf('c'); //效率最高的方法2. String s = String.valueOf(new char[]{'c'}); //将一个char数组转换成String3. String s = \"\" + 'c';// 虽然这个方法很简单，但这是效率最低的方法4. String s = new String(new char[]{'c'}); 进制转换12String s=Integer.toString(8, 2);//1000：8转化为1000B二进制字符串//Integer.toString(val,进制)","link":"/2019/03/22/Java_Transform/"},{"title":"Markdown","text":"标题这是 H1这是 H2这是 H312345#### 标题# 这是 H1## 这是 H2### 这是 H3 段落 This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in,laoreet vitae, risus. 123456789#### 段落&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in,laoreet vitae, risus. 列表 This is a list This is a list This is a list This is a list This is a list This is a list This is a list This is a list 123456789101112#### 列表- This is a list- This is a list - This is a list - This is a list1. This is a list2. This is a list 1. This is a list 2. This is a list 代码Use the printf() function. 123&lt;div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 1System.out.println(); 强调single asterisks single underscores double asterisks double underscores 123456789#### 强调*single asterisks*_single underscores_**double asterisks**__double underscores__ 标点符号 符号 标点 &copy; 版权 \\ 反斜线 &reg; 注册商标 ` 反引号 &trade; 商标 * 星号 &nbsp; 空格 _ 底线 &amp; 和号 {} 花括号 &quot; 引号 [] 方括号 &apos; 撇号 () 括弧 &lt; 小于号 # 井字号 &gt; 大于号 + 加号 &ne; 不等号 - 减号 &le; 小于等于 . 英文句点 &ge; 大于等于 ! 惊叹号 &cent; 分 &pound; 磅 &euro; 欧元 &yen; 元 &sect; 节 &times; 乘号 &divide; 除号 &plusmn; 正负号 123456789101112131415161718192021222324#### 标点符号符号 | | 标点 | |------- | ------- | ------- | -------&amp;copy; | 版权 | \\\\ | 反斜线&amp;reg; | 注册商标 | \\` | 反引号&amp;trade; | 商标 | \\* | 星号&amp;nbsp; | 空格 | \\_ | 底线&amp;amp; | 和号 | \\{\\} | 花括号&amp;quot; | 引号 | \\[\\] | 方括号&amp;apos; | 撇号 | \\(\\) | 括弧&amp;lt; | 小于号 | \\# | 井字号&amp;gt; | 大于号 | \\+ | 加号&amp;ne; | 不等号 | \\- | 减号&amp;le; | 小于等于 | \\. | 英文句点&amp;ge; | 大于等于 | \\! | 惊叹号&amp;cent; | 分 | | &amp;pound; | 磅 | | &amp;euro; | 欧元 | | &amp;yen; | 元 | | &amp;sect; | 节 | | &amp;times; | 乘号 | | &amp;divide; | 除号 | | &amp;plusmn; | 正负号 | | 其他 删除线 下划线 123~~删除线~~&lt;u&gt;下划线&lt;/u&gt;","link":"/2019/03/18/MarkDown/"}],"tags":[{"name":"指针","slug":"指针","link":"/tags/指针/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"EverMonkey","slug":"EverMonkey","link":"/tags/EverMonkey/"},{"name":"印象笔记","slug":"印象笔记","link":"/tags/印象笔记/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"励志","slug":"励志","link":"/tags/励志/"},{"name":"感动","slug":"感动","link":"/tags/感动/"},{"name":"鸡汤","slug":"鸡汤","link":"/tags/鸡汤/"},{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Arrays","slug":"Arrays","link":"/tags/Arrays/"},{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"TreeMap","slug":"TreeMap","link":"/tags/TreeMap/"},{"name":"ArrayList","slug":"ArrayList","link":"/tags/ArrayList/"},{"name":"Math_Java","slug":"Math-Java","link":"/tags/Math-Java/"},{"name":"BigInteger","slug":"BigInteger","link":"/tags/BigInteger/"},{"name":"BigDecimal","slug":"BigDecimal","link":"/tags/BigDecimal/"},{"name":"递归","slug":"递归","link":"/tags/递归/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"查找","slug":"查找","link":"/tags/查找/"},{"name":"Search","slug":"Search","link":"/tags/Search/"},{"name":"线性结构","slug":"线性结构","link":"/tags/线性结构/"},{"name":"SequenceList","slug":"SequenceList","link":"/tags/SequenceList/"},{"name":"顺序表","slug":"顺序表","link":"/tags/顺序表/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"类型转换","slug":"类型转换","link":"/tags/类型转换/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"}],"categories":[{"name":"C Notes","slug":"C-Notes","link":"/categories/C-Notes/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"KeepThinking","slug":"KeepThinking","link":"/categories/KeepThinking/"},{"name":"Grammar","slug":"Grammar","link":"/categories/Grammar/"},{"name":"Js Notes","slug":"Js-Notes","link":"/categories/Js-Notes/"},{"name":"Java Notes","slug":"Java-Notes","link":"/categories/Java-Notes/"}]}