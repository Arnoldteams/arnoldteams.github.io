{"pages":[],"posts":[{"title":"DFS深度优先搜索","text":"递归解法(可能导致堆栈溢出)12345678910boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) { return true if cur is target; for (next : each neighbor of cur) { if (next is not in visited) { add next to visted; return true if DFS(next, target, visited) == true; } } return false;} 非递归解法1234567891011121314151617boolean DFS(int root,int target){ Set&lt;Node&gt; visited; Stack&lt;Node&gt; s; add root to s; while(s is not empty){ Node cur = the top element in s; return true if cur is target; for(Node next : the neighbors of cur){ if(next is not in visited){ add next to s; add next to visited; } } remove cur from s ; } return false;} 这里，只要深刻的理解了栈的概念就很容易理解。 我们来看一个简单的问题 二叉树的中序遍历输出TreeNode中节点的值 中序遍历：左-&gt;中-&gt;右 树的节点123456public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }} 递归解法： 12345678910111213141516class Solution { List&lt;Integer&gt; list = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { f1(root); return list; } void f1(TreeNode root){ if(root == null) return ; //当有左节点的时候就一直递归到没有左节点为止。 inorderTraversal(root.left); //第一次运行到这里的时候，这一定是最左边的节点。 list.add(root.val); //第一次运行到这里的时候，左边节点和父节点已经遍历了。 inorderTraversal(root.right); }} 迭代解法： 12","link":"/2019/03/23/DFS/"},{"title":"触动心灵的话","text":"孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为：我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。","link":"/2019/03/22/GoodWords/"},{"title":"HashMap&TreeMap","text":"HashMap： 数组方式存储key/value，线程非安全，允许null作为key和value，key不可以重复，value允许重复，不保证元素迭代顺序是按照插入时的顺序，要求key必须重写equals和hashcode方法。 TreeMap： 基于红黑二叉树实现，线程非安全，不允许null，key不可以重复，value允许重复，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，默认升序，两个相比较的key不得抛出classCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出。 HashMap：1234567891011121314151617181. 存入键值对V put ( K key, V value )//向map中添加键值对后，返回这个key对应以前的value,如果以前没有则返回nullV putIfAbsent (K key, V value)// 在输入键值对前，会先判断map中是否有相同key，如果有就不覆盖，返回原有的value，如果没有就返回null，并直接存入。E.g:hashMap.putIfAbsent(\"A\",16); hashMap.putIfAbsent(\"A\",17);hashMap.putIfAbsent(\"B\", 100); hashMap.putIfAbsent(\"B\", 150);hashMap.put(\"C\", 222); hashMap.put(\"C\", 23);Out：A=16, B=100, C=23void putAll ( Map&lt;? extends K,? extends V&gt; m)//把一个其他map复制过来 123456789101112131415162. 通过键取值 V get(K key)//如果map有key则获取value，没有则返回null，也有可能有key但对应的value就是null，所以不能用get判断是否存在某个key。V getOrDefault(K key, V defaultValue)//如果map有key则获取value，没有则返回自定义的defaultValue3. 键或值是否存在boolean containsValue(Object value)boolean containsKey(Object key)4. 替换键值对V replace(K key, V Value)//如果map中存在key则将其对应的value替换为参数里的value，并返回以前的value，如果不存在key则返回null。boolean replace(K key, V oldValue, V newValue)//匹配map中对应的键值对，如果完全符合就替换，不符合就返回false。void replaceAll(BiFunction function)//对所有键值对进行替换 123456789101112131415161718192021225. 删除键值对V remove(K key)//通过key删除键值对，返回key对应的value，如果不存在key返回nullboolean remove(K key, V Value)//只有完全匹配参数中的键值对才删除。6. 元素数据处理（函数式编程）V computeIfPresent(K key, BiFunctionsuper K, ? super V, ? extends V&gt; remappingFunction)V computeIfAbsent (K key, Functionsuper K, ? extends V&gt; mappingFunction)V compute (K key, BiFunctionsuper K, ? super V, ? extends V&gt; remappingFunction)V merge(K key, V value,BiFunction remappingFunction)//上面这些功能简单来说就是 用自定义方法更新key对应的value。void forEach ( BiConsumer action)//这个更好理解了，就是对map所有键值对进行操作7. 获取 键/值 的集合Collection&lt;V&gt; values()//获取map中的所有value，并存入CollectionSet&lt;K&gt; keySet()//获取map中的所有key，存入setSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()//获取map中所有键值对，存入set，注意这里的返回类型是个map特有的接口Map.Entry的set集合，一个Map.Entry接口对应map中的一个键值对，Map.Entry是个静态接口，可以通过foreach或迭代器，调用每个接口的set/get方法，其实Map.Entry可以看作键值对的实体类 TreeMap：注意：之所以会有这些方法，是因为treemap是有序的。查找限定范围内的一个key或entry1234567891011121314151617181920212223Map.Entry&lt;K,V&gt; ceilingEntry(K key)K ceilingKey(K key)//查找大于等于参数key的map里包含的最小key或entry，没有就返回nullMap.Entry&lt;K,V&gt; floorEntry(K key)K floorKey(K key)//查找小于等于参数key的map里包含的最大key或entry，没有就返回nullMap.Entry&lt;K,V&gt; lowerEntry(K key)K lowerKey(K key)//查找小于参数key的map里包含的最大key或entry，没有就返回nullMap.Entry&lt;K,V&gt; higherEntry(K key)K higherKey(K key)//查找大于参数key的map里包含的最小key或entry，没有就返回nullMap.Entry&lt;K,V&gt; firstEntry(K key)K firstKey(K key)//查找map中最小的键（第一个）Map.Entry&lt;K,V&gt; lastEntry(K key)K lastKey(K key) //查找map中最大的键（最后一个）3. 删除最大或最小键值对SortedMap&lt;K,V&gt; headMap(K toKey)//返回Key小于toKey的所有元素Map.Entry&lt;K,V&gt; pollFirstEntry() Map.Entry&lt;K,V&gt; pollLastEntry() //返回被删除的键值对 Link: TreeMap","link":"/2019/03/23/HashMap&TreeMap/"},{"title":"HexoTest","text":"1 Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 2 NEW: DevDocs now comes with syntax highlighting. DevDocstwitter.com/devdocs/status/356095192085962752 3 1234567public class SinglyListNode { int val; SinglyListNode next; SinglyListNode(int x) { val = x; }} 1234for(int i=0;i&lt;length;i++) { printf(\"%3d\",a[i]); } 4 Arrays.sort()12Arrays.sort(a[]);int a=0; 5 _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 6 7 Hexo Tag Plugins 8 content","link":"/2019/03/20/Hexo/"},{"title":"查找Java版","text":"顺序查找 基本思想： 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第n个和第n-1个，将小数放前，大数放后。然后比较第n-1个数和第n-2个数，将小数放前，大数放后，如此继续，直至全部排序完成。 123456789101112 /** * 顺序查找 * @param 数组；查找的元素 * @return 下标 */static int SequenceSearch(int[] a,int num) { for (int i = 0; i &lt; a.length; i++) { if(a[i]==num) return i+1; } return -1;} 折半（二分）查找 基本思想： 搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。仅限有序数组 123456789101112131415161718192021/*** 二分查找(只能查找有序数组)* @param 数组；查找的元素* @return 下标*/ static int BinarySearch(int[] a,int num) { int low = 0; int high = a.length-1; int mid; while(low&lt;=high) { mid = (low + high) / 2; if(a[mid] &gt; num) { high=mid-1; }else if(a[mid] &lt; num) { low=mid+1; }else { return mid+1; } } return -1; } 分块查找 基本思想： 将n个数据元素按块有序划分为m块（m&lt;=n）。每一块中的数据元素不必有序，但块与块之间必须“按块有序”，即第1快中的任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都小于第3块中的任一元素，……；块间用二分查找，块内用顺序查找 12345/*** 二分查找(只能查找有序数组)* @param 数组；查找的元素* @return 下标*/","link":"/2019/03/21/JavaSearch/"},{"title":"排序Java版","text":"冒泡排序 基本思想： 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第n个和第n-1个，将小数放前，大数放后。然后比较第n-1个数和第n-2个数，将小数放前，大数放后，如此继续，直至全部排序完成。 12345678910111213141516171819/** * 冒泡排序 * @param 数组 * @return 排好序的数组 */ static int[] BubbleSort(int[] a) { for (int i = a.length-1; i &gt;= 0; i--) { for (int j = i; j &gt; 0; j--) { if(a[j]&lt;a[j-1]) swap(a, j, j-1); } } return a; } static void swap(int[] a,int i,int j) { int t=a[i]; a[i]=a[j]; a[j]=t; } 插入排序 基本思想： 把n个待排序的元素看成一个有序表和一个无序表，开始时有序表中只有一个元素，无序表中有n-1个元素；排序过程即每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表，重复n-1次完成整个排序过程。 12345678910111213141516171819202122/** * 插入排序Eg： [9| 7, 4, 0, 5] [7, 9| 4, 0, 5] [4, 7, 9| 0, 5] [0, 4, 7, 9| 5] [0, 4, 5, 7, 9] */static int[] InsertSort (int a[]) { int t=0; for (int i = 1; i &lt; a.length; i++) { t=a[i]; for (int j = i-1 ; j &gt;= 0; j--) { if(t&lt;a[j]) swap(a,j,j+1); else continue; }// System.out.println(Arrays.toString(a)); } return a;} 时间复杂度 排序法 最差时间分析 平均时间复杂度 稳定度 空间复杂度 冒泡排序 O(n2) O(n2) 稳定 O(1) 快速排序 O(n2) O(n*log2n) 不稳定 O(log2n)~O(n) 选择排序 O(n2) O(n2) 不稳定 O(1) 二叉树排序 O(n2) O(n*log2n) 不一定 O(n) 插入排序 O(n2) O(n2) 稳定 O(1) 堆排序 O(n*log2n) O(n*log2n) 不稳定 O(1) 希尔排序 O O 不稳定 O(1)","link":"/2019/03/21/JavaSort/"},{"title":"Markdown","text":"标题这是 H1这是 H2这是 H312345#### 标题# 这是 H1## 这是 H2### 这是 H3 段落 This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in,laoreet vitae, risus. 123456789#### 段落&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in,laoreet vitae, risus. 列表 This is a list This is a list This is a list This is a list This is a list This is a list This is a list This is a list 123456789101112#### 列表- This is a list- This is a list - This is a list - This is a list1. This is a list2. This is a list 1. This is a list 2. This is a list 代码Use the printf() function. 123&lt;div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 1System.out.println(); 强调single asterisks single underscores double asterisks double underscores 12345678910#### 强调*single asterisks*_single underscores_**double asterisks**__double underscores__","link":"/2019/03/18/MarkDown/"},{"title":"Math数学常用方法","text":"Math 1234567891011Math.sqrt()//计算平方根Math.cbrt()//计算立方根Math.pow(a, b)//计算a的b次方Math.max( , );//计算最大值Math.min( , );//计算最小值Math.abs()//abs求绝对值Math.ceil()//向上取整Math.floor()//向下取整Math.random()//随机数Math.round()//四舍五入Math.rint//四舍六入五凑偶 BigInteger (BigDecimal 用法相同)12345678910public BigInteger add(BigInteger val)public BigInteger subtract(BigInteger val)public BigInteger multiply(BigInteger val)public BigInteger divide(BigInteger val)\"int compareTo(Biglnteger other)//如果这个大整数与另一个大整数相等，返回0; 如果这个大整数小于另一个大整数, 返回负数；否则，返回正数","link":"/2019/03/23/Math/"},{"title":"EverMonkey印象笔记插件","text":"开始使用 打开命令面板(F1 或者 ctrl+shift+p), 输入以下命令即可操作印象笔记。 新建笔记 – ever new 新建一个空白笔记, 文档顶部是笔记元数据，包括笔记的标题，标签，所属笔记本等(不支持分级)。 当输入笔记本和标签时，如果是已经存在的，则会有代码补全提示，否则将会在印象笔记中新建。标签需要用半角逗号分隔。 打开笔记 – ever open 以树形结构打开印象笔记。选中笔记后，默认会将笔记的内容转换为 markdown 格式，如果有不支持的媒体格式，那么转换后可能会影响笔记的内容。如果在多端进行编辑也会出现 html 标签的情况。 搜索笔记 – ever search 根据输入的搜索条件返回印象笔记。返回的形式是 notebook&gt;&gt;note, 搜索使用的是印象笔记官方的搜索语言，比如 tag:java 等。更多使用方法可以查看官方文档 Evernote Search Grammar 发布笔记 – ever publish 当编辑或者更新笔记后，可以使用 ever publish 命令将笔记发布到印象笔记服务器上，实现笔记的同步。monkey 会根据缓存信息判断是需要新建还是更新笔记, 更新成功后会弹出消息。 打开最近编辑的笔记 – ever recent 打开最近编辑过的笔记。选中笔记后，默认会将笔记的内容转换为 markdown 格式，如果有不支持的媒体格式，那么转换后可能会影响笔记的内容。如果在多端进行编辑也会出现 html 标签的情况。 在浏览器中打开编辑的笔记 – ever browse 在印象笔记网页端打开当前编辑的笔记，如果还未发布，则无法打开。如果在网页端中编辑文档内容，再次在vscode中打开笔记时，渲染markdown会导致一些原生html被渲染。 在客户端中浏览编辑的笔记 – ever everclient 在印象笔记客户端中打开编辑的笔记，如果还未发布，则无法打开。如果在客户端中编辑文档内容，再次在vscode中打开笔记时，渲染markdown会导致一些原生html被渲染。 上传附件到当前编辑的笔记 – ever attach 如果已经配置了 uploadFolder, 可以将附件放到对应的文件夹下，输入文件名即可实现上传。否则，需要输入文件的绝对路径。上传后的附件是缓存在本地的，需要使用 ever publish 命令将附件上传。 取消上传附件到当前编辑的笔记 – ever unattach 如果附件上传后还没有 publish, 此时可以使用 ever unattach 命令进行取消。 注: monkey 中不提供任何删除服务器端笔记的命令！ 浏览当前编辑笔记的附件 – ever resources 浏览当前编辑的笔记。其中会以 (server), (local) 的形式区分本地附件和服务器附件。如果是服务器端的附件，选中后会临时下载到 attachmentsFolder 中, 并使用默认应用打开附件。 如果是本地附件，则会直接使用默认应用打开。 同步笔记账户 – ever sync 同步笔记账户，这个命令会在第一次使用 monkey 的时候调用，并将结果缓存到内存中。如果没有缓存报错(通常是由于网络原因导致请求失败，本地缓存失效), 或者在多端使用印象笔记，不建议使用此命令。可能会由于印象笔记限流导致，账户暂时无法调用 API。 打开印象笔记开发者网页 – ever token 获取 token 和 noteStoreUrl。","link":"/2019/03/23/evermonkey/"},{"title":"My First Page","text":"Deploy to remote sites1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d More info: Deployment","link":"/2018/12/18/hello-world/"},{"title":"递归","text":"递归问题：我们可以用「分而治之」的概念去帮助理解。步骤如下： 把问题分解成更容易解决的子问题集合（比如可以把计算斐波那契数列的第n项问题分解转换成计算第n-1项加上第n-2项这两个子问题） 假设我们有一个函数可以应用在所有的子问题上（比如计算斐波那契数列的fibo函数） 基于步骤2的函数，实现如何把子问题的解拼成最终问题的解，这就是递归部分（在计算斐波那契数列的例子里就是fibo(n-1) + fibo(n-2)部分） 递归部分确定了，然后再考虑子问题最终简化到到最底层时该返回什么值（不能再分的原子情况）。 E.g：问题描述 每年冬天，北大未名湖上都是滑冰的好地方。北大体育组准备了许多冰鞋，可是人太多了，每天下午收工后，常常一双冰鞋都不剩。 每天早上，租鞋窗口都会排起长龙，假设有还鞋的m个，有需要租鞋的n个。现在的问题是，这些人有多少种排法，可以避免出现体育组没有冰鞋可租的尴尬场面。（两个同样需求的人（比如都是租鞋或都是还鞋）交换位置是同一种排法）输入格式 两个整数，表示m和n输出格式 一个整数，表示队伍的排法的方案数。样例输入3 2样例输出5数据规模和约定m,n∈［0,18］ 1234567891011121314151617181920import java.util.*;public class Main{ public static void main(String[] args){ Scanner in = new Scanner(System.in); int m=in.nextInt();//send int n=in.nextInt();//get System.out.println(cal(m,n)); } static int cal(int m,int n) { if(n&gt;m) { return 0; } if(n==0) { return 1; } return cal(m-1,n)+cal(m,n-1); }} 类似问题 计算m个a n个b 的排列数 1234567891011121314151617181920public class Main{ /** * 计算m个a n个b 的排列数 */ public static void main(String[] args){ Scanner in = new Scanner(System.in); int m=in.nextInt();//a int n=in.nextInt();//b System.out.println(cal(m,n)); } static int cal(int a,int b) { if(a==0&amp;&amp;b==0) { return 0; } if(a==0||b==0) { return 1; } return cal(a-1,b)+cal(a,b-1); }} 计算斐波那契数 123456789101112131415161718192021import java.util.*;public class Main{ /** * 计算斐波那契数 */ public static void main(String[] args){ Scanner in = new Scanner(System.in); int n=in.nextInt();//a System.out.println(cal(n)); } static int cal(int n) { if(n==0) return 0; if(n==1) return 1; return cal(n-1)+cal(n-2);//第n个数为n-1,n-2的和 }}","link":"/2019/03/22/recursion/"},{"title":"类型转换&进制转换(Java)","text":"类型转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//int-&gt;String1：String s=i+\"\";2：String s=String.valueOf(i);//int-&gt;char1:char c = (char)('0' + i);2:char c = (char)(48+ i);3:char c = String.valueOf(i).charAt(0);//String-&gt;int1：i=Integer.parseInt(s);2：i=Integer.valueOf(s).intValue();//Integer.valueOf(s) //转换数字字符串以外类型会抛出异常//String-&gt;byte[]1:byte[] b=s.getBytes();//String -&gt; char1. String.charAt(index)//（返回值为char）可以得到String中某一指定位置的char。2. String.toCharArray()//（返回值为char[]）可以得到将包含整个String的char数组。这样我们就能够使用从0开始的位置索引来访问string中的任意位置的元素。//byte[]-&gt;String1:String s=new String(b)//ASCII-&gt;char1:char c = (char) 68;//D //char-&gt;ASCIISystem.out.println((int)'c');//99//char-&gt;int1:int i=Integer.parseInt(String.valueOf(c)) ;2:int i=c-'0';//char -&gt;String1. String s = String.valueOf('c'); //效率最高的方法2. String s = String.valueOf(new char[]{'c'}); //将一个char数组转换成String3. String s = \"\" + 'c';// 虽然这个方法很简单，但这是效率最低的方法4. String s = new String(new char[]{'c'}); 进制转换12String s=Integer.toString(8, 2);//1000：8转化为1000B二进制字符串//Integer.toString(val,进制)","link":"/2019/03/22/transform/"}],"tags":[{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"励志","slug":"励志","link":"/tags/励志/"},{"name":"感动","slug":"感动","link":"/tags/感动/"},{"name":"鸡汤","slug":"鸡汤","link":"/tags/鸡汤/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"TreeMap","slug":"TreeMap","link":"/tags/TreeMap/"},{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"查找","slug":"查找","link":"/tags/查找/"},{"name":"Search","slug":"Search","link":"/tags/Search/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Math_Java","slug":"Math-Java","link":"/tags/Math-Java/"},{"name":"BigInteger","slug":"BigInteger","link":"/tags/BigInteger/"},{"name":"BigDecimal","slug":"BigDecimal","link":"/tags/BigDecimal/"},{"name":"EverMonkey","slug":"EverMonkey","link":"/tags/EverMonkey/"},{"name":"印象笔记","slug":"印象笔记","link":"/tags/印象笔记/"},{"name":"递归","slug":"递归","link":"/tags/递归/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"类型转换","slug":"类型转换","link":"/tags/类型转换/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"KeepThinking","slug":"KeepThinking","link":"/categories/KeepThinking/"},{"name":"Java Notes","slug":"Java-Notes","link":"/categories/Java-Notes/"},{"name":"Grammar","slug":"Grammar","link":"/categories/Grammar/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"}]}