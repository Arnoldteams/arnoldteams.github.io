{"pages":[{"title":"","text":"var arr = ['A', '', 'B', null, undefined, 'B', ' ']; var r = arr.filter(function (s) { return s && s.trim(); // 注意：IE9以下的版本没有trim()方法 }); console.log(r);","link":"/test/test2.js"},{"title":"","text":"function get_primes(arr) { var r=[]; r = arr.filter(function(x){ var t=0; for (let index = 1; index","link":"/test/test.js"}],"posts":[{"title":"C语言 指针","text":"建立数组123456char a[6];a[0]='s';a[1]='w';a[2]='3';a[5]='q';char *t=a; a 为固定指针是数组a的首地址，不可直接进行运算。但可以通过以 [基地址+偏移量] 的思想来进行操作。 1234567printf(\"1--%d\\n\",a); //a 数组的首地址,即a[0]的地址 printf(\"2--%d\\n\",&amp;a); //a 数组的首地址printf(\"3--%d\\n\",&amp;a[5]); //a[5]的地址, printf(\"4--%s\\n\",&amp;a[1]); //a数组中从a[1]开始的字符串，{w3} printf(\"5--%c\\n\",a[1]); //a[1]的内容(char),{w}printf(\"6--%d\\n\",*a); //a[0]的内容(char),{115} t为浮动指针，初始化为指向数组a的首地址（注意区分a,t的不同），可直接进行运算来操作。 1234567printf(\"8--%d\\n\",t); //a 数组的首地址printf(\"9--%d\\n\",&amp;t); //t指针的地址printf(\"10--%d\\n\",&amp;t[5]); //a[5]的地址printf(\"11--%s\\n\",&amp;t[1]);//a数组中从a[0]开始的字符串，{w3} printf(\"12--%c\\n\",t[0]);//a[1]的内容(char),{w}printf(\"13--%c\\n\",*t); //a[0]的内容(char),{115} 对t进行操作123456t++;printf(\"14--%d\\n\",t); //a[1] 的地址*t='c';printf(\"15--%c\\n\",*t); //a[1] 的值，{c} printf(\"16--%s\\n\",&amp;a[0]); //a数组中从a[0]开始的字符串 ，{sc3}","link":"/2019/12/23/Pointer/"},{"title":"DFS深度优先搜索","text":"递归解法(可能导致堆栈溢出)12345678910boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) { return true if cur is target; for (next : each neighbor of cur) { if (next is not in visited) { add next to visted; return true if DFS(next, target, visited) == true; } } return false;} 非递归解法1234567891011121314151617boolean DFS(int root,int target){ Set&lt;Node&gt; visited; Stack&lt;Node&gt; s; add root to s; while(s is not empty){ Node cur = the top element in s; return true if cur is target; for(Node next : the neighbors of cur){ if(next is not in visited){ add next to s; add next to visited; } } remove cur from s ; } return false;} 这里，只要深刻的理解了栈的概念就很容易理解。 我们来看一个简单的问题 二叉树的中序遍历输出TreeNode中节点的值 中序遍历：左-&gt;中-&gt;右 树的节点123456public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; }} 递归解法： 12345678910111213141516class Solution { List&lt;Integer&gt; list = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { f1(root); return list; } void f1(TreeNode root){ if(root == null) return ; //当有左节点的时候就一直递归到没有左节点为止。 inorderTraversal(root.left); //第一次运行到这里的时候，这一定是最左边的节点。 list.add(root.val); //第一次运行到这里的时候，左边节点和父节点已经遍历了。 inorderTraversal(root.right); }} 迭代解法： 123456789101112131415161718192021222324252627class Solution { //用于输出结果的数组。 List&lt;Integer&gt; list = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { //如果当前节点不为空将其放入栈中。 Stack&lt;TreeNode&gt; st = new Stack(); //curr指针指向root TreeNode curr = root; //查找所有子节点 while(curr!=null||!st.isEmpty()){ //不为空就继续找下一个左节点。并压入栈中。 if(curr!=null){ st.push(curr); curr = curr.left; }else{ /* 如果当前节点为空，有两种情况。 1.到了最左边。 2.到了最右边。 */ curr = st.pop(); list.add(curr.val); curr = curr.right; } } return list; }","link":"/2019/12/23/AlgorithmNotes/Alg_DFS/"},{"title":"Arrays常用方法","text":"1.Arrays.fill(Object[] array, Object obj) 填充 12345678910//用指定元素填充整个数组（会替换掉数组中原来的元素）Integer[] data = {1, 2, 3, 4};Arrays.fill(data, 9);System.out.println(Arrays.toString(data)); // [9, 9, 9, 9]Arrays.fill(Object[] array, int fromIndex, int toIndex, Object obj)Integer[] data = {1, 2, 3, 4};Arrays.fill(data, 0, 2, 9);System.out.println(Arrays.toString(data)); // [9, 9, 3, 4] 2.Arrays.sort(Object[] array) 排序 1234567891011//对数组元素进行排序（串行排序）String[] data = {\"1\", \"4\", \"3\", \"2\"};System.out.println(Arrays.toString(data)); // [1, 4, 3, 2]Arrays.sort(data);System.out.println(Arrays.toString(data)); // [1, 2, 3, 4]Arrays.sort(data, 0, 3);// 对下标[0, 3)的元素进行排序，即对1，4，3进行排序，2保持不变System.out.println(Arrays.toString(data)); // [1, 3, 4, 2]Arrays.parallelSort(T[] array)//对数组元素进行排序（并行排序），当数据规模较大时，会有更好的性能 3.Arrays.binarySearch(Object[] array, Object key) 查找（二分法） 注意: 在调用该方法之前，必须先调用sort()方法进行排序，如果数组没有排序，那么结果是不确定的，此外如果数组中包含多个指定元素，则无法保证将找到哪个元素1234567Integer[] data = {1, 3, 5, 7};Arrays.sort(data);System.out.println(Arrays.binarySearch(data, 1)); // 0System.out.println(Arrays.binarySearch(data, 0)); // -1 ；-(0 + 1) = -1System.out.println(Arrays.binarySearch(data, 8)); // -5 ；-(4 + 1) = -5System.out.println(Arrays.binarySearch(data, 2)); // -2 ；-(1 + 1) = -2System.out.println(Arrays.binarySearch(data, 0, 2, 3)); // 1 4.Arrays.copyOf(T[] original, int newLength) 拷贝数组 12345678Integer[] data1 = {1, 2, 3, 4};Integer[] data2 = Arrays.copyOf(data1, 2);System.out.println(Arrays.toString(data2)); // [1, 2]Integer[] data2 = Arrays.copyOf(data1, 5);System.out.println(Arrays.toString(data2)); // [1, 2, 3, 4, null]Arrays.copyOfRange(T[] original, int from, int to)//指定起始位置和结束位置，如果超过原数组长度，会用null进行填充 5.Arrays.equals(Object[] array1, Object[] array2) 判断两个数组是否相等 12345678910//实际上比较的是两个数组的哈希值，即 Arrays.hashCode(data1) == Arrays.hashCode(data2)Integer[] data1 = {1, 2, 3};Integer[] data2 = {1, 2, 3};System.out.println(Arrays.equals(data1, data2)); // trueArrays.deepEquals(Object[] array1, Object[] array2)//判断两个多维数组是否相等，实际上比较的是两个数组的哈希值，即 :Arrays.hashCode(data1) == Arrays.hashCode(data2) 6.Arrays.hashCode(Object[] array) 哈希值 123456//返回数组的哈希值Integer[] data = {1, 2, 3};System.out.println(Arrays.hashCode(data)); // 30817 Arrays.deepHashCode(Object[] array)//返回多维数组的哈希值 7.Arrays.toString(Object[] array) 输出 123456789//返回数组元素的字符串形式Integer[] data = {1, 2, 3};System.out.println(Arrays.toString(data)); // [1, 2, 3]Arrays.deepToString(Object[] array)//返回多维数组元素的字符串形式Integer[][] data = {{1, 2, 3}, {1, 2, 3}};System.out.println(Arrays.deepToString(data)); // [[1, 2, 3], [1, 2, 3]] 8.Arrays.setAll(T[] array, IntFunction) 123Integer[] data = {1, 2, 3, 4}; // i为索引值Arrays.setAll(data, i -&gt; data[i] * 2);System.out.println(Arrays.toString(data)); // [2, 4, 6, 8] 9.Arrays.stream(T[] array) 1234//返回数组的流Stream，然后我们就可以使用Stream相关的许多方法了Integer[] data = {1, 2, 3, 4};List&lt;Integer&gt; list = Arrays.stream(data).collect(toList());System.out.println(list); // [1, 2, 3, 4]","link":"/2019/12/23/JavaNotes/Java_Arr/"},{"title":"ArrayList常用方法","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 创建一个空的数组链表对象list，list用来存放String类型的数据 // 增加元素到list对象中 list.add(\"Item1\"); list.add(\"Item2\"); list.add(2, \"Item3\"); // 此条语句将会把“Item3”字符串增加到list的第3个位置。 list.add(\"Item4\");// 检查元素的位置 int pos = list.indexOf(\"Item2\"); System.out.println(\"The index of Item2 is: \" + pos); // 检查数组链表是否为空 boolean check = list.isEmpty(); System.out.println(\"Checking if the arraylist is empty: \" + check); // 获取链表的大小 int size = list.size(); System.out.println(\"The size of the list is: \" + size); // 检查数组链表中是否包含某元素 boolean element = list.contains(\"Item5\"); System.out .println(\"Checking if the arraylist contains the object Item5: \" + element); // 获取指定位置上的元素 String item = list.get(0); System.out.println(\"The item is the index 0 is: \" + item); // 使用迭代器遍历list for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext();) { System.out.println(\"Item is: \" + it.next()); } // 替换元素 list.set(1, \"NewItem\"); System.out.println(\"The arraylist after the replacement is: \" + list); // 移除第0个位置上的元素 list.remove(0); // 移除第一次找到的 \"Item3\"元素 list.remove(\"Item3\"); // 转换 ArrayList 为 Array String[] simpleArray = list.toArray(new String[list.size()]);","link":"/2019/12/23/JavaNotes/Java_ArrayList/"},{"title":"HashMap&TreeMap","text":"HashMap： 数组方式存储key/value，线程非安全，允许null作为key和value，key不可以重复，value允许重复，不保证元素迭代顺序是按照插入时的顺序，要求key必须重写equals和hashcode方法。 TreeMap： 基于红黑二叉树实现，线程非安全，不允许null，key不可以重复，value允许重复，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，默认升序，两个相比较的key不得抛出classCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出。 HashMap：1234567891011121314151617181. 存入键值对V put ( K key, V value )//向map中添加键值对后，返回这个key对应以前的value,如果以前没有则返回nullV putIfAbsent (K key, V value)// 在输入键值对前，会先判断map中是否有相同key，如果有就不覆盖，返回原有的value，如果没有就返回null，并直接存入。E.g:hashMap.putIfAbsent(\"A\",16); hashMap.putIfAbsent(\"A\",17);hashMap.putIfAbsent(\"B\", 100); hashMap.putIfAbsent(\"B\", 150);hashMap.put(\"C\", 222); hashMap.put(\"C\", 23);Out：A=16, B=100, C=23void putAll ( Map&lt;? extends K,? extends V&gt; m)//把一个其他map复制过来 123456789101112131415162. 通过键取值 V get(K key)//如果map有key则获取value，没有则返回null，也有可能有key但对应的value就是null，所以不能用get判断是否存在某个key。V getOrDefault(K key, V defaultValue)//如果map有key则获取value，没有则返回自定义的defaultValue3. 键或值是否存在boolean containsValue(Object value)boolean containsKey(Object key)4. 替换键值对V replace(K key, V Value)//如果map中存在key则将其对应的value替换为参数里的value，并返回以前的value，如果不存在key则返回null。boolean replace(K key, V oldValue, V newValue)//匹配map中对应的键值对，如果完全符合就替换，不符合就返回false。void replaceAll(BiFunction function)//对所有键值对进行替换 123456789101112131415161718192021225. 删除键值对V remove(K key)//通过key删除键值对，返回key对应的value，如果不存在key返回nullboolean remove(K key, V Value)//只有完全匹配参数中的键值对才删除。6. 元素数据处理（函数式编程）V computeIfPresent(K key, BiFunctionsuper K, ? super V, ? extends V&gt; remappingFunction)V computeIfAbsent (K key, Functionsuper K, ? extends V&gt; mappingFunction)V compute (K key, BiFunctionsuper K, ? super V, ? extends V&gt; remappingFunction)V merge(K key, V value,BiFunction remappingFunction)//上面这些功能简单来说就是 用自定义方法更新key对应的value。void forEach ( BiConsumer action)//这个更好理解了，就是对map所有键值对进行操作7. 获取 键/值 的集合Collection&lt;V&gt; values()//获取map中的所有value，并存入CollectionSet&lt;K&gt; keySet()//获取map中的所有key，存入setSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()//获取map中所有键值对，存入set，注意这里的返回类型是个map特有的接口Map.Entry的set集合，一个Map.Entry接口对应map中的一个键值对，Map.Entry是个静态接口，可以通过foreach或迭代器，调用每个接口的set/get方法，其实Map.Entry可以看作键值对的实体类 TreeMap：注意：之所以会有这些方法，是因为treemap是有序的。查找限定范围内的一个key或entry1234567891011121314151617181920212223Map.Entry&lt;K,V&gt; ceilingEntry(K key)K ceilingKey(K key)//查找大于等于参数key的map里包含的最小key或entry，没有就返回nullMap.Entry&lt;K,V&gt; floorEntry(K key)K floorKey(K key)//查找小于等于参数key的map里包含的最大key或entry，没有就返回nullMap.Entry&lt;K,V&gt; lowerEntry(K key)K lowerKey(K key)//查找小于参数key的map里包含的最大key或entry，没有就返回nullMap.Entry&lt;K,V&gt; higherEntry(K key)K higherKey(K key)//查找大于参数key的map里包含的最小key或entry，没有就返回nullMap.Entry&lt;K,V&gt; firstEntry(K key)K firstKey(K key)//查找map中最小的键（第一个）Map.Entry&lt;K,V&gt; lastEntry(K key)K lastKey(K key) //查找map中最大的键（最后一个）3. 删除最大或最小键值对SortedMap&lt;K,V&gt; headMap(K toKey)//返回Key小于toKey的所有元素Map.Entry&lt;K,V&gt; pollFirstEntry() Map.Entry&lt;K,V&gt; pollLastEntry() //返回被删除的键值对 Link: TreeMap","link":"/2019/12/23/JavaNotes/Java_HashMap&TreeMap/"},{"title":"LinkedList常用方法","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public E getFirst()//获取头元素public E getLast()public E removeFirst()//删除public E removeLast()public E remove(int index)//删除指定位置的元素public boolean remove(Object o)//删除指定值的元素public boolean add(E e) //增加public void addFirst(E e)public void addLast(E e)public void add(int index, E element)//在指定位置插入指定元素public boolean contains(Object o)//测试列表是否包含某元素，包含返回truepublic int size()//返回链表大小public boolean remove(Object o)//删除列表中第一个遇到的指定元素，成功返回truepublic boolean addAll(Collection&lt;? extends E&gt; c)//把指定集合中的所有元素追加到列表末尾，成功返回truepublic E get(int index)//返回元素在列表中位置public E set(int index, E element)//用指定元素E替换原指定位置的元素，返回被替换的元素public int indexOf(Object o)//返回第一个遇到的指定元素的位置，没有返回-1public int lastIndexOf(Object o)//返回最后一个遇到的指定元素的位置Integer[] str=link.toArray(new Integer[link.size()]);//LinkedList-&gt;&lt;T&gt;[] ArrayList&lt;Integer&gt; myList = new ArrayList&lt;Integer&gt;(link);//LinkedList-&gt;ArrayList","link":"/2019/12/23/JavaNotes/Java_LinkedList/"},{"title":"Math数学常用方法","text":"Math1234567891011Math.sqrt()//计算平方根Math.cbrt()//计算立方根Math.pow(a, b)//计算a的b次方Math.max( , );//计算最大值Math.min( , );//计算最小值Math.abs()//abs求绝对值Math.ceil()//向上取整Math.floor()//向下取整Math.random()//随机数Math.round()//四舍五入Math.rint//四舍六入五凑偶 BigInteger (BigDecimal 用法相同)12345678910public BigInteger add(BigInteger val)public BigInteger subtract(BigInteger val)public BigInteger multiply(BigInteger val)public BigInteger divide(BigInteger val)\"int compareTo(Biglnteger other)//如果这个大整数与另一个大整数相等，返回0; 如果这个大整数小于另一个大整数, 返回负数；否则，返回正数","link":"/2019/12/23/JavaNotes/Java_Math/"},{"title":"递归","text":"递归问题：我们可以用「分而治之」的概念去帮助理解。步骤如下： 把问题分解成更容易解决的子问题集合（比如可以把计算斐波那契数列的第n项问题分解转换成计算第n-1项加上第n-2项这两个子问题） 假设我们有一个函数可以应用在所有的子问题上（比如计算斐波那契数列的fibo函数） 基于步骤2的函数，实现如何把子问题的解拼成最终问题的解，这就是递归部分（在计算斐波那契数列的例子里就是fibo(n-1) + fibo(n-2)部分） 递归部分确定了，然后再考虑子问题最终简化到到最底层时该返回什么值（不能再分的原子情况）。 E.g：问题描述 每年冬天，北大未名湖上都是滑冰的好地方。北大体育组准备了许多冰鞋，可是人太多了，每天下午收工后，常常一双冰鞋都不剩。 每天早上，租鞋窗口都会排起长龙，假设有还鞋的m个，有需要租鞋的n个。现在的问题是，这些人有多少种排法，可以避免出现体育组没有冰鞋可租的尴尬场面。（两个同样需求的人（比如都是租鞋或都是还鞋）交换位置是同一种排法）输入格式 两个整数，表示m和n输出格式 一个整数，表示队伍的排法的方案数。样例输入3 2样例输出5数据规模和约定m,n∈［0,18］ 1234567891011121314151617181920import java.util.*;public class Main{ public static void main(String[] args){ Scanner in = new Scanner(System.in); int m=in.nextInt();//send int n=in.nextInt();//get System.out.println(cal(m,n)); } static int cal(int m,int n) { if(n&gt;m) { return 0; } if(n==0) { return 1; } return cal(m-1,n)+cal(m,n-1); }} 类似问题 计算m个a n个b 的排列数 1234567891011121314151617181920public class Main{ /** * 计算m个a n个b 的排列数 */ public static void main(String[] args){ Scanner in = new Scanner(System.in); int m=in.nextInt();//a int n=in.nextInt();//b System.out.println(cal(m,n)); } static int cal(int a,int b) { if(a==0&amp;&amp;b==0) { return 0; } if(a==0||b==0) { return 1; } return cal(a-1,b)+cal(a,b-1); }} 计算斐波那契数 123456789101112131415161718192021import java.util.*;public class Main{ /** * 计算斐波那契数 */ public static void main(String[] args){ Scanner in = new Scanner(System.in); int n=in.nextInt();//a System.out.println(cal(n)); } static int cal(int n) { if(n==0) return 0; if(n==1) return 1; return cal(n-1)+cal(n-2);//第n个数为n-1,n-2的和 }}","link":"/2019/12/23/JavaNotes/Java_Recursion/"},{"title":"查找Java版（线性结构）","text":"顺序查找 基本思想： 依次查找 SequenceSearch123456789101112 /** * 顺序查找 * @param 数组；查找的元素 * @return 下标 */static int SequenceSearch(int[] a,int num) { for (int i = 0; i &lt; a.length; i++) { if(a[i]==num) return i+1; } return -1;} 折半（二分）查找 基本思想： 搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。仅限有序数组 BinarySearch123456789101112131415161718192021 /** * 二分查找(只能查找有序数组) * @param 数组；查找的元素 * @return 下标 */static int BinarySearch(int[] a, int num) { int low = 0; int high = a.length - 1; int mid; while (low &lt;= high) { mid = (low + high) / 2; if (a[mid] &gt; num) { high = mid - 1; } else if (a[mid] &lt; num) { low = mid + 1; } else { return mid + 1; } } return -1;} 分块查找 基本思想： 将n个数据元素按块有序划分为m块（m&lt;=n）。每一块中的数据元素不必有序，但块与块之间必须“按块有序”，即第1快中的任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都小于第3块中的任一元素，……；块间用顺序 OR 二分查找，块内用顺序查找 TestData12int[][] tab= {{24,1},{54,7},{78,10},{88,13}};//索引表int[] a= {24,21,6,11,8,22,32,31,54,72,61,78,88,83};//查找数组 DivideSearch123456789101112131415161718192021222324/** * @param 查找数组；索引表；查找元素 * @return 下标 * 采用顺序+顺序（也可以使用二分+顺序实现） */static int DivideSearch(int[] a, int[][] tab, int num) { int start = -1; for (int i = 0; i &lt; tab.length; i++) { if (tab[i][0] == num) return tab[i][1]; if (tab[i][0] &gt; num) { start = tab[i][1] - 1; continue; } } if (start == -1) return -1; for (int i = start; i &gt;= 0; i--) { if (a[i] == num) return i + 1; } return -1;}","link":"/2019/12/23/JavaNotes/Java_Search1/"},{"title":"SequenceList_Java 顺序表","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.Arrays;public class SequenceList&lt;T&gt; { static int MaxSize = 10; private T[] data; int length; public SequenceList() { } public boolean InitList(T[] list) { // 初始化 data = Arrays.copyOf(list, MaxSize); length = list.length; return true; } public boolean ListInsert(int i, T a) { // 插入 if (i &lt; 1 || i &gt; length + 1 || length &gt;= MaxSize) return false; for (int j = length; j &gt;= i; j--) { data[j] = data[j - 1]; } data[i - 1] = a; length++; return true; } public Object ListDelete(int i) { // 删除 if (i &lt; 1 &amp;&amp; i &gt; length + 1) return -1; T temp = data[i - 1]; for (int j = i; j &lt; length; j++) { data[j - 1] = data[j]; } length--; data[length] = null; return temp; } public int LocateElem(T a) { // 获取元素位置 for (int i = 0; i &lt; length; i++) { if (data[i] == a) return i + 1; } return -1; } public Object GetElem(int i) { // 获取元素 if (i &lt; 1 &amp;&amp; i &gt; length + 1) return -1; return data[i - 1]; } public int Length() { // 长度 return this.length; } public void print() { // 打印 System.out.println(Arrays.toString(data)); } public boolean Empty() { // 判断是否为空 if (data.length == 0) return true; return false; }//Test public static void main(String[] args) { Integer[] a = { 1, 2, 3, 4, 5 };// 使用int初始化会发生异常 SequenceList&lt;Integer&gt; list = new SequenceList&lt;Integer&gt;(); System.out.println(\"Init:\" + list.InitList(a)); System.out.println(\"Insert:\" + list.ListInsert(1, 66)); System.out.println(\"Delete:\" + list.ListDelete(4)); System.out.println(\"GetNum:\" + list.GetElem(4)); System.out.println(\"LocElem:\" + list.LocateElem(66)); System.out.println(\"Length:\" + list.length); System.out.println(\"Empty:\" + list.Empty()); list.print(); }}","link":"/2019/12/23/JavaNotes/Java_SequenceList/"},{"title":"排序Java版(插入排序)","text":"直接插入排序 基本思想： 把n个待排序的元素看成一个有序表和一个无序表，开始时有序表中只有一个元素，无序表中有n-1个元素；排序过程即每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表，重复n-1次完成整个排序过程。 InsertSort123456789101112131415161718192021/** * 插入排序Eg： [9| 7, 4, 0, 5] [7, 9| 4, 0, 5] [4, 7, 9| 0, 5] [0, 4, 7, 9| 5] [0, 4, 5, 7, 9] */static int[] InsertSort (int a[]) { int t=0; for (int i = 1; i &lt; a.length; i++) { t=a[i]; for (int j = i-1 ; j &gt;= 0; j--) { if(t&lt;a[j]) swap(a,j,j+1); else continue; } } return a;} 时间复杂度 排序法 最差时间分析 平均时间复杂度 稳定度 空间复杂度 冒泡排序 O(n^2) O(n^2) 稳定 O(1) 快速排序 O(n^2) O(n*log2n) 不稳定 O(log2n)~O(n) 选择排序 O(n^2) O(n^2) 不稳定 O(1) 二叉树排序 O(n^2) O(n*log2n) 不一定 O(n) 插入排序 O(n^2) O(n^2) 稳定 O(1) 堆排序 O(n*log2n) O(n*log2n) 不稳定 O(1) 希尔排序 O O 不稳定 O(1)","link":"/2019/12/23/JavaNotes/Java_Sort1/"},{"title":"排序Java版(交换排序)","text":"冒泡排序 基本思想： 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第n个和第n-1个，将小数放前，大数放后。然后比较第n-1个数和第n-2个数，将小数放前，大数放后，如此继续，直至全部排序完成。 BubbleSort123456789101112131415161718192021222324252627282930 /** * 冒泡排序 * @param 数组 * @return 排好序的数组 *///v1.0 由尾到头排序static int[] BubbleSort(int[] a) { for (int i = a.length - 1; i &gt;= 0; i--) { for (int j = i; j &gt; 0; j--) { if (a[j] &lt; a[j - 1]) swap(a, j, j - 1); } } return a;}//v2.0 由头到尾排序static int[] BubbleSort(int[] a) { for (int i = 0; i &lt;=a.length - 1; i++) { for (int j = i+1; j &lt;=a.length - 1; j++) { if (a[i] &gt; a[j]) swap(a, i, j); } } return a;}static void swap(int[] a, int i, int j) { int t = a[i]; a[i] = a[j]; a[j] = t;} 快速排序 基本思想： 第一趟选取一个哨兵，以哨兵为分界进行划分，将数组划分为 [low] 哨兵 [high] 使得 [low] 的所有元素均小于哨兵元素，[high] 的所有元素均大于哨兵元素（也就是说哨兵这个元素已经排到正确位置了），之后以这个哨兵为界分别对 [low] [high] 进行划分，递归进行直到完成排序 QuickSort12345678910111213141516171819202122232425262728293031323334353637 /** * 快速排序 * @param 数组，数组下限，数组上限 * @return 排好序的数组 */static int[] QuickSort(int[] a, int low, int high) { if (low &lt; high) { int pos = Partition(a, low, high); QuickSort(a, low, pos - 1); QuickSort(a, pos + 1, high); } return a;} /** * 划分 * @param 数组，数组下限，数组上限 * @return 哨兵的位置 */static int Partition(int[] a, int low, int high) { int sentry = a[low];// 哨兵 while (low &lt; high) { // 实现[low] 哨兵 [high] 的排序；当low=high时候结束循环 while (low &lt; high &amp;&amp; a[high] &gt;= sentry) { // 从high-&gt;low遍历；发现第一个a[high]&lt;哨兵 结束循环 high--; } a[low] = a[high]; // 将这个小于哨兵的元素移至哨兵左边[low] while (low &lt; high &amp;&amp; a[low] &lt;= sentry) { // 从low-&gt;high遍历；发现第一个a[high]&gt;哨兵 结束循环 low++; } a[high] = a[low]; // 将这个大于于哨兵的元素移至哨兵右边[high] } a[low] = sentry;// 哨兵放到正确的位置 return low;// 返回哨兵的位置，这时 哨兵的左边&lt;哨兵；哨兵的右边&gt;哨兵}","link":"/2019/12/23/JavaNotes/Java_Sort2/"},{"title":"String常用方法","text":"12345678910111213141516171819202122232425261 length（）字符串的长度; isEmpty()判空2 charAt（）截取一个字符 String a = \"Hello Word\"; System.out.println(a.charAt(1));//输出的结果是字符串a的下标为1的字符e。3 getchars（）截取多个字符并由其他字符串接收 String a = \"Hello Word\"; char[] b = new char[10]; a.getChars(0, 5, b, 0); System.out.println(b);//输出的结果为Hello4 getBytes()将字符串变成一个byte数组 String a = \"Hello Word\"; byte b[] = a.getBytes(); System.out.println(new String(b));//输出的结果为Hello Word的byte数组。5 toCharArray()将字符串变成一个字符数组 String a = \"Hello Word\"; char[]b = a.toCharArray(); System.out.println(b);//输出的结果为Hello Word字符数组。 12345678910111213141516171819202122232425262728296 equals()和equalsIgnoreCase()比较两个字符串是否相等，前者区分大小写，后者不区分 String a = \"Hello Word\"; String b = \"hello word\"; System.out.println(a.equals(b));//false System.out.println(a.equalsIgnoreCase(b));//true7 startsWith()和endsWith()判断字符串是不是以特定的字符开头或结束 String a = \"Hello Word\"; System.out.println(a.startsWith(\"ee\"));//false System.out.println(a.endsWith(\"rd\"));//true8 toUpperCase()和toLowerCase()将字符串转换为大写或小写 String a = \"Hello Word\"; System.out.println(a.toUpperCase());//HELLO WORD System.out.println(a.toLowerCase());//hello word9 concat() 连接两个字符串 String a = \"Hello Word\"; String b = \"你好\"; System.out.println(b.concat(a));//你好Hello Word10 trim()去掉起始和结束的空格 String a = \" Hello Word \"; System.out.println(a.trim());//Hello Word 123456789101112131415161718192021222324252627282930313233343511 substring（）截取字符串 String a = \"Hello Word\"; System.out.println(a.substring(0, 5));//Hello System.out.println(a.substring(6));//World12 indexOf()和lastIndexOf()前者是查找字符或字符串第一次出现的地方，后者是查找字符或字符串最后一次出现的地方 String a = \"Hello Word\"; System.out.println(a.indexOf(\"o\"));//4 System.out.println(a.lastIndexOf(\"o\"));//713 compareTo()和compareToIgnoreCase(）按字典顺序比较两个字符串的大小，前者区分大小写，后者不区分 String a = \"Hello Word\"; String b = \"hello word\"; System.out.println(a.compareTo(b));//-32 System.out.println(a.compareToIgnoreCase(b));//014 replace() 替换 String s=\"abc\"; System.out.println(s.replace('a', 'w'));//wbc System.out.println(s.replaceFirst(\"bc\", \"cde\"));//acde15 contains() 字符串匹配 String s=\"ab,cd,ef\"; System.out.println(s.contains(\"ef\"));//true System.out.println(s.contains(\"ecf\"));//false16 split 拆分字符串 String s=\"sa sf gaf asd\"; String[] a=s.split(\" \");//[sa, sf, gaf,asd]","link":"/2019/12/23/JavaNotes/Java_Str/"},{"title":"类型转换&进制转换(Java)","text":"类型转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//int-&gt;String1：String s=i+\"\";2：String s=String.valueOf(i);//int-&gt;char1:char c = (char)('0' + i);2:char c = (char)(48+ i);3:char c = String.valueOf(i).charAt(0);//String-&gt;int1：i=Integer.parseInt(s);2：i=Integer.valueOf(s).intValue();//Integer.valueOf(s) //转换数字字符串以外类型会抛出异常//String-&gt;byte[]1:byte[] b=s.getBytes();//String -&gt; char1. String.charAt(index)//（返回值为char）可以得到String中某一指定位置的char。2. String.toCharArray()//（返回值为char[]）可以得到将包含整个String的char数组。这样我们就能够使用从0开始的位置索引来访问string中的任意位置的元素。//byte[]-&gt;String1:String s=new String(b)//ASCII-&gt;char1:char c = (char) 68;//D //char-&gt;ASCIISystem.out.println((int)'c');//99//char-&gt;int1:int i=Integer.parseInt(String.valueOf(c)) ;2:int i=c-'0';//char -&gt;String1. String s = String.valueOf('c'); //效率最高的方法2. String s = String.valueOf(new char[]{'c'}); //将一个char数组转换成String3. String s = \"\" + 'c';// 虽然这个方法很简单，但这是效率最低的方法4. String s = new String(new char[]{'c'}); 进制转换12String s=Integer.toString(8, 2);//1000：8转化为1000B二进制字符串//Integer.toString(val,进制)","link":"/2019/12/23/JavaNotes/Java_Transform/"},{"title":"","text":"对象 123456789101112131415161718192021222324//创建对象var xiaohong = { name: '小红', age: 16, 'middle-school': 'No.1 Middle School'};//访问对象属性（不存在的属性返回undefined）xiaohong['middle-school']; // 'No.1 Middle School'xiaohong['name']; // '小红'xiaohong.name; // '小红'//删除属性delete xiaohong.age; // 删除age属性//检测属性(继承的属性也有效)'name' in xiaohong; // true'toString' in xiaohong; // true//检测属性(过滤继承的属性)xiaohong.hasOwnProperty('name'); // true'toString' in xiaohong; // false 对象中this的使用 this.birth：undefined12345678910111213var xiaoming = { name: '小明', birth: 1990, age: function () { function getAgeFromBirth() { var y = new Date().getFullYear(); return y - this.birth; } return getAgeFromBirth(); }};xiaoming.age(); Uncaught TypeError: Cannot read property 'birth' of undefined this的传递：this.birth：19901234567891011121314var xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this } return getAgeFromBirth(); }};xiaoming.age(); // 25 指定this的指向123456function getAge() { var y = new Date().getFullYear(); return y - this.birth;}getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 变量 把代码全部放入唯一的名字空间中，会大大减少全局变量冲突的可能 1234567891011// 唯一的全局变量MYAPP:var MYAPP = {};// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () { return 'foo';}; 批量赋值 1234567891011121314151617var [x, y, z] = ['hello', 'JavaScript', 'ES6'];//x = hello, y = JavaScript, z = ES6var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};var {name, age, passport} = person;//name = 小明, age = 20, passport = G-12345678// 如果person对象没有single属性，默认赋值为true:var {name, single=true} = person;name; // '小明'single; // true","link":"/2019/12/23/JavaScriptNotes/JavaScript_Obj/"},{"title":"字符串 数组","text":"字符串 转义字符 1'I\\'m \\\"OK\\\"!';//表示的字符串内容是：I'm \"OK\"! 按位置查找 1234var s = 'Hello, world!';s[0]; // 'H's[6]; // ' 's[7]; // 'w' toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf()搜索指定字符串出现的位置 字符串截取 substring()123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' 数组 length 修改 1234var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined] 索引赋值超限 123var arr = [1, 2, 3];arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 按位置查找 indexOf()12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 截取 slice()123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] push和pop(尾操作) 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift和shift（头操作） 123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] 排序 sort() 翻转 reverse() 元素的添加和删除 splice()12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] 连接 concat()1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] join()12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3'","link":"/2019/12/23/JavaScriptNotes/JavaScript_Str&Arr/"},{"title":"","text":"函数 函数定义123456789101112131415function abs(x) { if (x &gt;= 0) { return x; } else { return -x; }}var abs = function (x) { if (x &gt;= 0) { return x; } else { return -x; }}; 关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数 1234567891011function abs() { if (arguments.length === 0) { return 0; } var x = arguments[0]; return x &gt;= 0 ? x : -x;}abs(); // 0abs(10); // 10abs(-9); // 9 获得除了定义之外的rest参数 1234567891011121314151617function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest);}foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] 解构赋值 123456789function buildDate({year, month, day, hour=0, minute=0, second=0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);}buildDate({ year: 2017, month: 1, day: 1 });// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 });// Sun Jan 01 2017 20:15:00 GMT+0800 (CST) 函数重写 1234window.parseInt = function () { count += 1; return oldParseInt.apply(null, arguments); // 调用原函数}; 函数传递 123function add(x, y, f) { return f(x) + f(y);} map()1234567function pow(x) { return x * x;}var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); console.log(results);// [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce()1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) { return x + y;}); // 25 filter()1234567891011121314151617181920212223var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) { return x % 2 !== 0;});r; // [1, 5, 9, 15]---------------------------------------- 删除空字符var arr = ['A', '', 'B', null, undefined, 'B', ' '];var r = arr.filter(function (s) { return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法});r; // ['A', 'B', 'B']-- 去除重复字符r = arr.filter(function (element, index, self) { return self.indexOf(element) === index; //indexOf总是返回第一个元素的位置,self 为所有元素 //element,index 为当前元素的值和下标});r; // ['A', 'B']","link":"/2019/12/23/JavaScriptNotes/JavaScript_fun/"},{"title":"","text":"shell脚本 gdb调试 编码风格 文档编写 概要设计、详细设计 -","link":"/2020/01/03/Job/Now/"},{"title":"Positive Psychology Lesson11","text":"","link":"/2019/12/23/PositivePsy/L11/"},{"title":"Dos常用命令","text":"dir 显示一个目录下的文件和子目录 dir [盘符:][目录路径][/p] [/s] [/w] [/o] [/p]表示分页显示目录内容，按任意键查看下一屏 [/s]表示显示所有目录及其子目录下的所有文件 [/w]表示宽屏显示 [/o]表示分类顺序显示 md（make directory）用于新建目录 md [盘符:][路径名]&lt;文件夹名&gt; md 文件夹名 表示在当前目录下创建文件夹 md e:\\zgt 表示在E盘下创建zgt文件夹 md e:\\zgt\\666 表示在E盘zgt文件夹下创建666文件 echo 回显 copy &lt;源文件路径&gt;[目标路径] cls 清除屏幕命令 ，清除屏幕上所有的显示，光标置于左上角 format 格式化磁盘 rmdir /s path 删除非空目录","link":"/2019/12/23/Tools/Dos/"},{"title":"EverMonkey印象笔记插件","text":"开始使用 打开命令面板(F1 或者 ctrl+shift+p), 输入以下命令即可操作印象笔记。 新建笔记 – ever new 新建一个空白笔记, 文档顶部是笔记元数据，包括笔记的标题，标签，所属笔记本等(不支持分级)。 当输入笔记本和标签时，如果是已经存在的，则会有代码补全提示，否则将会在印象笔记中新建。标签需要用半角逗号分隔。 打开笔记 – ever open 以树形结构打开印象笔记。选中笔记后，默认会将笔记的内容转换为 markdown 格式，如果有不支持的媒体格式，那么转换后可能会影响笔记的内容。如果在多端进行编辑也会出现 html 标签的情况。 搜索笔记 – ever search 根据输入的搜索条件返回印象笔记。返回的形式是 notebook&gt;&gt;note, 搜索使用的是印象笔记官方的搜索语言，比如 tag:java 等。更多使用方法可以查看官方文档 Evernote Search Grammar 发布笔记 – ever publish 当编辑或者更新笔记后，可以使用 ever publish 命令将笔记发布到印象笔记服务器上，实现笔记的同步。monkey 会根据缓存信息判断是需要新建还是更新笔记, 更新成功后会弹出消息。 打开最近编辑的笔记 – ever recent 打开最近编辑过的笔记。选中笔记后，默认会将笔记的内容转换为 markdown 格式，如果有不支持的媒体格式，那么转换后可能会影响笔记的内容。如果在多端进行编辑也会出现 html 标签的情况。 在浏览器中打开编辑的笔记 – ever browse 在印象笔记网页端打开当前编辑的笔记，如果还未发布，则无法打开。如果在网页端中编辑文档内容，再次在vscode中打开笔记时，渲染markdown会导致一些原生html被渲染。 在客户端中浏览编辑的笔记 – ever everclient 在印象笔记客户端中打开编辑的笔记，如果还未发布，则无法打开。如果在客户端中编辑文档内容，再次在vscode中打开笔记时，渲染markdown会导致一些原生html被渲染。 上传附件到当前编辑的笔记 – ever attach 如果已经配置了 uploadFolder, 可以将附件放到对应的文件夹下，输入文件名即可实现上传。否则，需要输入文件的绝对路径。上传后的附件是缓存在本地的，需要使用 ever publish 命令将附件上传。 取消上传附件到当前编辑的笔记 – ever unattach 如果附件上传后还没有 publish, 此时可以使用 ever unattach 命令进行取消。 注: monkey 中不提供任何删除服务器端笔记的命令！ 浏览当前编辑笔记的附件 – ever resources 浏览当前编辑的笔记。其中会以 (server), (local) 的形式区分本地附件和服务器附件。如果是服务器端的附件，选中后会临时下载到 attachmentsFolder 中, 并使用默认应用打开附件。 如果是本地附件，则会直接使用默认应用打开。 同步笔记账户 – ever sync 同步笔记账户，这个命令会在第一次使用 monkey 的时候调用，并将结果缓存到内存中。如果没有缓存报错(通常是由于网络原因导致请求失败，本地缓存失效), 或者在多端使用印象笔记，不建议使用此命令。可能会由于印象笔记限流导致，账户暂时无法调用 API。 打开印象笔记开发者网页 – ever token 获取 token 和 noteStoreUrl。","link":"/2019/12/23/Tools/Evermonkey/"},{"title":"Git Start!","text":"常用命令 123pwd 用于显示当前目录mkdir 建立目录touch 建立文件 Git Git 基本操作 git init 选择一个空目录初始化 创建指定目录learngit并加入readme 1234$ mkdir learngit$ cd learngit/$ touch readme.txt$ git add readme.txt //可反复多次使用，添加多个文件到暂存区 git status 查看添加到工作区与暂存区的内容是否一致 当在本地发生了修改可以通过git diff查看修改的变化$ git diff readme.txt 提交所有暂存区的内容到仓库+提交说明（方便管理）$ git commit -m &quot;wrote a readme file&quot; 可以使用git log查看提交的日志，通过commit后的版本号回退版本commit 461a4c83a94bc47621c873d30b9165db9e48c78d 查看日志图表 $ git log --graph 查看简洁版日志图表 $ git log --graph --pretty=oneline --abbrev-commit 回退 回退暂存区的特定文件（暂存区-&gt;工作区）$ git reset -- filename 回退到前一个版本$ git reset --hard HEAD^ 回退到特定版本（使用版本号不发生重复的前n位&gt;3）$ git reset --hard 461a 查询恢复版本的记录$ git reflog 撤销工作区的修改（暂存区-&gt;工作区）$ git checkout -- readme.txt 撤销暂存区的修改（仓库-&gt;暂存区）$ git reset HEAD readme.txt 删除文件使用git rm将修改保存到暂存区$ git rm readme.txt 连接本地仓库到GitHub 创建SSH Key$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 将id_rsa.pub 添加到GitHub 登陆GitHub-&gt;“Account settings”-&gt;“SSH Keys”添加“SSH Key”，任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 GitHub上建立新仓库learngit 本地与在线仓库关联$ git remote add origin git@github.com:arnoldteams/learngit.git 远程库的名字是origin关联仓库为arnoldteams/learngit 将本地推送到GitHub仓库$ git push -u origin master推送失败可以先进行合并$ git pull --rebase origin master 连接完成后若本地仓库发生修改进行推送$ git push origin master GitHub 仓库克隆到本地$ git clone git@github.com:arnoldteams/learngit.git或者$ git clone https://github.com/Arnoldteams/learngit 分支 初始只有master分支 添加dev分支 创建及切换分支 方法112$ git branch dev$ git checkout dev 方法21$ git checkout -b dev 查看所有分支git branch 向dev提交 合并分支 合并dev到当前分支$ git merge dev 保留新分支进行合并$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 删除分支$ git branch -d dev","link":"/2019/12/23/Tools/Git/"},{"title":"HexoTest","text":"1 Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 2 NEW: DevDocs now comes with syntax highlighting. DevDocstwitter.com/devdocs/status/356095192085962752 3 1234567public class SinglyListNode { int val; SinglyListNode next; SinglyListNode(int x) { val = x; }} 1234for(int i=0;i&lt;length;i++) { printf(\"%3d\",a[i]); } 4 Arrays.sort()12Arrays.sort(a[]);int a=0; 5 _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 6 7 Hexo Tag Plugins 8 content","link":"/2019/12/23/Tools/Hexo/"},{"title":"Markdown","text":"标题这是 H1这是 H2这是 H312345#### 标题# 这是 H1## 这是 H2### 这是 H3 段落 This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in,laoreet vitae, risus. 123456789#### 段落&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in,laoreet vitae, risus. 列表 This is a list This is a list This is a list This is a list This is a list This is a list This is a list This is a list 123456789101112#### 列表- This is a list- This is a list - This is a list - This is a list1. This is a list2. This is a list 1. This is a list 2. This is a list 代码Use the printf() function. 123&lt;div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 1System.out.println(); 强调single asterisks single underscores double asterisks double underscores 123456789#### 强调*single asterisks*_single underscores_**double asterisks**__double underscores__ 标点符号 符号 标点 &copy; 版权 \\ 反斜线 &reg; 注册商标 ` 反引号 &trade; 商标 * 星号 &nbsp; 空格 _ 底线 &amp; 和号 {} 花括号 &quot; 引号 [] 方括号 &apos; 撇号 () 括弧 &lt; 小于号 # 井字号 &gt; 大于号 + 加号 &ne; 不等号 - 减号 &le; 小于等于 . 英文句点 &ge; 大于等于 ! 惊叹号 &cent; 分 &pound; 磅 &euro; 欧元 &yen; 元 &sect; 节 &times; 乘号 &divide; 除号 &plusmn; 正负号 123456789101112131415161718192021222324#### 标点符号符号 | | 标点 | |------- | ------- | ------- | -------&amp;copy; | 版权 | \\\\ | 反斜线&amp;reg; | 注册商标 | \\` | 反引号&amp;trade; | 商标 | \\* | 星号&amp;nbsp; | 空格 | \\_ | 底线&amp;amp; | 和号 | \\{\\} | 花括号&amp;quot; | 引号 | \\[\\] | 方括号&amp;apos; | 撇号 | \\(\\) | 括弧&amp;lt; | 小于号 | \\# | 井字号&amp;gt; | 大于号 | \\+ | 加号&amp;ne; | 不等号 | \\- | 减号&amp;le; | 小于等于 | \\. | 英文句点&amp;ge; | 大于等于 | \\! | 惊叹号&amp;cent; | 分 | | &amp;pound; | 磅 | | &amp;euro; | 欧元 | | &amp;yen; | 元 | | &amp;sect; | 节 | | &amp;times; | 乘号 | | &amp;divide; | 除号 | | &amp;plusmn; | 正负号 | | 其他 删除线 下划线 123~~删除线~~&lt;u&gt;下划线&lt;/u&gt;","link":"/2019/12/23/Tools/MarkDown/"},{"title":"blogSetup","text":"安装必备软件 VScode Node.js（需要配置环境变量） git必要的初始化 将D:\\arnoldteams.github.io\\node_modules.bin 添加到环境变量Path中 npm install -g hexo 在本地创建ssh git config –global user.name “这里换上你的用户名” git config –global user.email “这里换上你的邮箱” ssh-keygen -t rsa -C “arnoldteams（github名）” 将ssh添加到GitHub 打开Sitting-&gt;选择SSH and GPG keys-&gt;New SSH key 添加本地的C:\\Users\\ateams.ssh\\id_rsa.pub文件的内容 部署 hexo g hexo s hexo d Markdown 插件Markdown Shortcuts","link":"/2019/12/23/Tools/blogSetup/"},{"title":"Vscode","text":"快捷键 Ctrl + B 粗体 I 斜体 Alt + S 删除线","link":"/2019/12/31/Tools/vscode/"},{"title":"C++基础","text":"命名空间 using 编译指令 using namespace std; 引用std的全部实体 域限定符 namespace example {} using声明机制 using std::cout; 仅引用需要的实体 尽量使用const来替换define宏定义的使用 const 指针 const int *p //无法改所指内容，可以改指向 int * const p//可以改所指内容，无法改指向 const int * const p//数据指向均不能变 数组的指针 int (p)[5] 指针的数组 int p[5] 函数的指针 int (a)(void) 指针函数 int a (void) 函数内的未初始化的指针为野指针–被随机分配的 内存泄漏–分配的内存未回收 malloc / free是C/C++语言的标准库函数;管理动态内存 new / delete是C++的运算符或表达式;自动分配空间初始化;构造和析构函数的调用 引用即是变量的别名，必须初始化，初始化后指向不会改变 普通函数的返回值是临时变量,不可取引用 不要返回堆空间的引用，会引起内存泄漏 堆中空闲块组成的空闲链，malloc从链表头依次查找空闲块，符合申请空间的空闲块从链表取出进行分配；free 将需要释放的块加入空闲链表示回收 A，B..，X 逗号表达式，返回值为X,与A B .. 无关 通过函数名的改编实现函数重载 C/C++混合编程 123456789#ifndef _cplusplusextern \"C\"{#endif/* c/c++ 代码段*/#ifndef _cplusplus}#endif 函数默认形参 fun(int a1,int a2 … int ak…int an); 如果k设置了默认参数，则ak…an全部需要设置默认参数 内联inline 仅可使用在函数实现的前面 inline int f(){}；写在定义前无效。 inline 函数中不要写循环 数组大小 sizeof(a)-1","link":"/2019/12/31/C/C++Note/1231/"},{"title":"Linux基础","text":"Linux 命令 目录ls 详情ls -l 大小ls -lh 显示隐藏ls -a 条件ls |grep {name} 查看当前目录下的文件数量（不包含子目录中的文件）ls -l|grep &quot;^-&quot;| wc -l 查看当前目录下的文件数量（包含子目录,R代表子目录)ls -lR|grep &quot;^-&quot;| wc -l 查看当前目录下的文件夹目录个数（不包含子目录中的目录） ls -l|grep “^d”| wc -l 树形目录tree {file} 安装apt install tree 路径pwd 权限chmod 777 {file} [拥有者][组用户][其他] 查找find {name} 指定目录按名查找find /abc -name file 复制cp 文件夹cp -r {file1} {file2} 移动mv 重命名 mv {dir1} {dir2} 创建 文件夹mkdir 文件touch {file}/echo -n&gt; {file} 查看cat 头部分head -n {n} 尾部分tail -n {n} 部分 more f和b前向后翻页q退出 删除rm 磁盘df -h 文件du -h –max-depth=0 链接li -s {file1} {file2} 用户 cat /etc/passwd 切换su {user} 退出exit 添加useradd {user} 添加到/home:useradd -m {user} -s /bin/bash 修改密码passwd {user} 删除userdel {user} -r/f 首次登陆需设置sudo密码 sudo passwd Vim h j k l / w e b移动 模式:i输入/v视图 ：q! 退出不保存/：w 保存/：q 退出/：e {file} 多标签 多标签切换Ctrl+^ 复制{n}yy, 复制n行-&gt;按p粘贴 删除{n}dd，删除n行-&gt;按u撤销 {n}x，删除n个字母 x,删除一个字母 行号 set nu 选定 Ctrl+v/v 分屏 ：vs/sp 切换 Ctrl+ww 注释选定 -&gt; shift+i -&gt; // -&gt; Esc GCC 预处理-&gt;编译-&gt;汇编-&gt;链接 静态库.a/.lib 必要文件vim multi.cvim multi.hvim main.c 建立静态库并移动到/usr/lib编译 gcc -c multi.c归档 ar crsv libmulti.a multi.osudo cp libmulti.a /usr/lib 链接并执行gcc -o main main.c -l multi./main 动态库.so/.dll 必要文件(同上) 建立动态库并移动到/usr/libgcc -fPIC -Wall -c multi.c -o multi2.ogcc -shared -o libmulti2.so multi2.osudo cp libmulti2.so /usr/lib 更新cachesudo ldconfig 链接并执行gcc main main.c -l multi2 GDB 显示部分行l 回车执行上一条命令 断点 b {n} 单步执行n 运行r 查看变量c的值 p c 进入函数 s 栈调用查看bt","link":"/2019/12/29/C/C++Note/1229/"},{"title":"C++基础","text":"代码规范 自定义类型名使用大写开头 类内成员变量使用 _name 来区分 成员函数，变量名驼峰命名E.g: setStudentName() 定义类首先写功能接口，底部是数据成员 类和对象 class 默认private ，struct 默认public 类内的函数默认inline函数 构造函数初始化分配资源：malloc / new 构造函数先执行初始化表达式,初始化的顺序与成员变量声明的顺序一致 析构函数 回收分配给对象的资源不是对象本身；对象本身需要由free/delete来销毁 栈，全局，静态 对象在程序结束是自动调用析构；堆对象 需要手动调用free/delete来销毁对象，销毁过程自动调用析构。 拷贝构造函数的调用：对新对象进行赋值时；传递参数为对象时 默认浅拷贝，因此涉及到内存空间操作时需要重写为深拷贝 使用引用&amp;符号为了防止无限递归调用 注：仅在已有对象对新对象赋值才会调用，已经存在的对象之间赋值不调用 赋值运算符函数：已经存在的对象间赋值 [a=b] 操作(内存泄漏，double free)；必须显式定义重载(释放a空间；再深拷贝b) 12345678910111213141516171819202122232425262728293031323334class Entity{public: Entity() ：num1(22) ,num2(33) //初始化表达式 { }//构造函数 ~Entity(){ }//析构函数 Entity(const Entity &amp;e){ }//拷贝构造函数 Entity &amp;operator=(const Entity &amp;e){ if(this!=&amp;e){//排除自复制的情况 delete a..;//先回收a a=new... ;//再赋值b } return *this;//返回拷贝的对象 }//赋值运算符函数private: static int num;//静态成员变量需要全局初始化 int num1; int num2; };int Entity::num=1;//全局初始化int main(){return 0;} const 成员函数：只能读取数据成员，只能调用const成员函数 123int fun () const{} 类外部定义成员函数需要在类内声明 内存空间（高-&gt;低） 内核区 栈 堆 静态常量区 拷贝 浅拷贝 仅copy地址 深拷贝 新开空间+拷贝内容 无法取地址的值为右值 lvalue—常量、临时对象 12345678910111213141516int num=1;//可以去地址：左值int &amp;a=num;//非const仅可左值引用const int &amp;b=1;//仅const可以右值引用；1为右值int fun(int &amp;a){}int cfun(const int &amp;a){}int f0(){ return 0;} fun(1)//Error ,非const仅可左值引用；1为右值fun(f0())//Error ,f0()返回右值cfun(f0())//正确 -","link":"/2020/01/02/C/C++Note/CppBasic/"},{"title":"C语言 指针","text":"建立数组123456char a[6];a[0]='s';a[1]='w';a[2]='3';a[5]='q';char *t=a; a 为固定指针是数组a的首地址，不可直接进行运算。但可以通过以 [基地址+偏移量] 的思想来进行操作。 1234567printf(\"1--%d\\n\",a); //a 数组的首地址,即a[0]的地址 printf(\"2--%d\\n\",&amp;a); //a 数组的首地址printf(\"3--%d\\n\",&amp;a[5]); //a[5]的地址, printf(\"4--%s\\n\",&amp;a[1]); //a数组中从a[1]开始的字符串，{w3} printf(\"5--%c\\n\",a[1]); //a[1]的内容(char),{w}printf(\"6--%d\\n\",*a); //a[0]的内容(char),{115} t为浮动指针，初始化为指向数组a的首地址（注意区分a,t的不同），可直接进行运算来操作。 1234567printf(\"8--%d\\n\",t); //a 数组的首地址printf(\"9--%d\\n\",&amp;t); //t指针的地址printf(\"10--%d\\n\",&amp;t[5]); //a[5]的地址printf(\"11--%s\\n\",&amp;t[1]);//a数组中从a[0]开始的字符串，{w3} printf(\"12--%c\\n\",t[0]);//a[1]的内容(char),{w}printf(\"13--%c\\n\",*t); //a[0]的内容(char),{115} 对t进行操作 123456t++;printf(\"14--%d\\n\",t); //a[1] 的地址*t='c';printf(\"15--%c\\n\",*t); //a[1] 的值，{c} printf(\"16--%c\\n\",a[1]); //a[1] 的值，{c} 注：char s[]=””;存放在栈区char *str=&quot;&quot;;存放在常量区","link":"/2019/12/23/C/C++Note/Pointer/"},{"title":"C++基础","text":"String 截取截取s中从pos开始的n个字符的子串 s.substr(pos, n) 替换用s1替换s中从pos开始n个字符的子串 s.replace(pos, n, s1) 查找查找s中第一次出现s1的位置，并返回 s.find(s1) 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置strchr(s1, ch)返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置 strstr(s1, s2) 长度 s.length() / s.size() /strlen(s) 复制字符串 s2 到字符串 s1strcpy(s1, s2) 连接字符串 s2 到字符串 s1 的末strcat(s1, s2) 连接s.append(str) 比较，如果 s1 和 s2 是相同的，则返回0；如果 s1&lt; s2 则返回&lt; 0；如果 s1&gt;s2 则返回值&gt; 0 strcmp(s1, s2)","link":"/2020/01/01/C/C++Note/String/"},{"title":"Stay Hungry!Stay Foolish!","text":"读书的目的 孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为：我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。 —龙应台 有意识的思考 不要让笔尖上的勤奋掩盖思维上的懒惰。 拒绝思维懒惰，习惯于深度思考，永远不要用战术上的勤奋掩盖战略上的懒惰。 微笑面对苦难 那些承载着苦难的时光，那些从根本上挑战每一份坚持的日子，将决定你是怎样的人。—谢丽尔·桑德 无论生活再艰难，也要用力活着—《荒野猎人》 风吹不倒有根的树。只要一息尚存，就战斗到底。 尊严的背后是实力 尊严只有在双方对等地位时才存在，弱者的尊严在强者面前一文不值，强者可以施舍给你“尊严”，但他可以以毫不犹豫的践踏，因为他是强者，与此拼命维护那施舍来的尊严，不如拼命提升自己的实力","link":"/2019/12/23/Experience/GoodWords/Good_Words001/"},{"title":"","text":"linux下各种命令、shell脚本。 linux C/C++编程，熟悉makefile，熟悉linux软件编译及调试过程 使用QT开发界面工程。 掌握数据结构，常用算法; 擅长沟通和团队协作能力; 具有较强的技术文档写作能力，能高质量完成开发、设计相关技术文档编写工作。 熟悉linux下pam登录机制。 熟悉linux下selinux安全机制。 makefile linux软件编译及调试 QT开发界面 pam登录机制 selinux安全机制 精通c/c++的基本原理和语法；熟悉Linux系统编程开发， 熟悉gdb调试； 熟悉DPDK的相关知识和编程，熟悉TCP/IP协议，熟悉协议分析和流量分析，具备信息安全领域技术经验者优先考虑； 精通本领域的各种编程语言和开发工具，可以独立完成大型产品的独立模块或者小型产品的开发工作； 具备较强的概要设计、详细设计和文档编写能力，能够独立查找、解决开发中出现的常见问题； DPDK TCP/IP协议 协议分析 流量分析 有linux c/c++开发经验，编码风格良好； 熟悉常用算法及设计模式；具有linux下网络抓包分析的经验； 熟悉http,https,smtp等常用网络协议知识； 熟悉代理服务器，中间件开发优先； 热爱编程、思路清晰、善于思考、能独立分析和解决问题； 团队协作，抗压能力强，从事过协议解析优先。 网络抓包 http,https,smtp协议 linux下网络抓包分析 代理服务器 中间件 协议解析 熟悉Linux下的C/C++开发；熟悉相关开发工具；了解数据库开发； 熟悉 linux系统编程、或内核编程、或linux文件过滤编程； 了解设计模式，有一定设计经验者优先； 良好的沟通协作能力。 数据库开发 内核编程 linux文件过滤编程 设计模式 熟悉Linux操作系统，熟悉 Linux 内核开发者优先 熟悉docker的常用操作和相关解决方案 有opencv实际开发经验懂docker容器优先， 有较强的独立工作能力和解决问题的能力，做事认真负责 具备良好的分析能力、表达能力和人际沟通能力 具有良好的英语文章阅读能 内核开发 docker opencv","link":"/2020/01/03/Job/C/C++Linux/"}],"tags":[{"name":"指针","slug":"指针","link":"/tags/指针/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"Arrays(Java)","slug":"Arrays-Java","link":"/tags/Arrays-Java/"},{"name":"ArrayList(Java)","slug":"ArrayList-Java","link":"/tags/ArrayList-Java/"},{"name":"HashMap(Java)","slug":"HashMap-Java","link":"/tags/HashMap-Java/"},{"name":"TreeMap(Java)","slug":"TreeMap-Java","link":"/tags/TreeMap-Java/"},{"name":"LinkedList(Java)","slug":"LinkedList-Java","link":"/tags/LinkedList-Java/"},{"name":"Java_Math","slug":"Java-Math","link":"/tags/Java-Math/"},{"name":"BigInteger","slug":"BigInteger","link":"/tags/BigInteger/"},{"name":"BigDecimal","slug":"BigDecimal","link":"/tags/BigDecimal/"},{"name":"递归(Java)","slug":"递归-Java","link":"/tags/递归-Java/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"查找(Java)","slug":"查找-Java","link":"/tags/查找-Java/"},{"name":"Java_Search","slug":"Java-Search","link":"/tags/Java-Search/"},{"name":"线性结构(Java)","slug":"线性结构-Java","link":"/tags/线性结构-Java/"},{"name":"Java_SequenceList","slug":"Java-SequenceList","link":"/tags/Java-SequenceList/"},{"name":"顺序表(Java)","slug":"顺序表-Java","link":"/tags/顺序表-Java/"},{"name":"排序(Java)","slug":"排序-Java","link":"/tags/排序-Java/"},{"name":"Java_Sort","slug":"Java-Sort","link":"/tags/Java-Sort/"},{"name":"字符串(Java)","slug":"字符串-Java","link":"/tags/字符串-Java/"},{"name":"类型转换(Java)","slug":"类型转换-Java","link":"/tags/类型转换-Java/"},{"name":"对象(Js)","slug":"对象-Js","link":"/tags/对象-Js/"},{"name":"变量(Js)","slug":"变量-Js","link":"/tags/变量-Js/"},{"name":"字符串(Js)","slug":"字符串-Js","link":"/tags/字符串-Js/"},{"name":"数组(Js)","slug":"数组-Js","link":"/tags/数组-Js/"},{"name":"函数(Js)","slug":"函数-Js","link":"/tags/函数-Js/"},{"name":"Psy","slug":"Psy","link":"/tags/Psy/"},{"name":"DOS","slug":"DOS","link":"/tags/DOS/"},{"name":"EverMonkey","slug":"EverMonkey","link":"/tags/EverMonkey/"},{"name":"印象笔记","slug":"印象笔记","link":"/tags/印象笔记/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Vscode","slug":"Vscode","link":"/tags/Vscode/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"linux命令","slug":"linux命令","link":"/tags/linux命令/"},{"name":"Vim，GCC","slug":"Vim，GCC","link":"/tags/Vim，GCC/"},{"name":"指针(C)","slug":"指针-C","link":"/tags/指针-C/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"励志","slug":"励志","link":"/tags/励志/"},{"name":"感动","slug":"感动","link":"/tags/感动/"},{"name":"鸡汤","slug":"鸡汤","link":"/tags/鸡汤/"}],"categories":[{"name":"C","slug":"C","link":"/categories/C/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Java Notes","slug":"Java-Notes","link":"/categories/Java-Notes/"},{"name":"Js Notes","slug":"Js-Notes","link":"/categories/Js-Notes/"},{"name":"Psy","slug":"Psy","link":"/categories/Psy/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Grammar","slug":"Grammar","link":"/categories/Grammar/"},{"name":"C Notes","slug":"C-Notes","link":"/categories/C-Notes/"},{"name":"KeepThinking","slug":"KeepThinking","link":"/categories/KeepThinking/"}]}